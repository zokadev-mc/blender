<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Jarvis 3D - Selecci√≥n Estricta</title>
    <style>
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: #eee; }
        #viewport { width: 100vw; height: 100vh; display: block; z-index: 0; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 10px; display: flex; flex-direction: column; justify-content: space-between; }
        .header { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; width: 100%; }
        .interactive { pointer-events: auto; }
        .mode-switch { background: #111; border: 1px solid #555; border-radius: 6px; display: flex; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.3); margin-bottom: 10px; }
        .mode-opt { padding: 10px 15px; font-size: 12px; font-weight: bold; color: #777; cursor: pointer; transition: all 0.2s; }
        .mode-opt.active { background: #e67e22; color: white; }
        .footer { display: flex; justify-content: center; pointer-events: none; padding-bottom: 20px; flex-direction: column; align-items: center; gap: 10px;}
        .transform-bar { background: rgba(30,30,30,0.95); border: 1px solid #555; border-radius: 12px; padding: 8px; display: flex; gap: 8px; backdrop-filter: blur(4px); box-shadow: 0 4px 10px rgba(0,0,0,0.4); pointer-events: auto; }
        button { background: #333; color: #ccc; border: 1px solid #444; padding: 12px 16px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        button.active { background: #3498db; color: #fff; border-color: #2980b9; }
        button.btn-green { background: #27ae60; color: white; }
        button.btn-danger { background: #c0392b; color: white; }
        button.btn-action { background: #f1c40f; color: #222; border: 1px solid #f39c12; font-weight: bold; box-shadow: 0 0 15px rgba(241, 196, 15, 0.6); transform: scale(1.1); }
        button.btn-tool { font-size: 18px; padding: 10px 14px; } 
        .btn-icon { padding: 10px 12px; font-size: 16px; }
        #status { position: absolute; top: 15px; left: 50%; transform:translateX(-50%); font-size: 13px; color: #fff; text-shadow: 1px 1px 2px black; pointer-events: none; background: rgba(0,0,0,0.7); padding: 6px 12px; border-radius: 20px; white-space: nowrap; border: 1px solid #444; transition: all 0.2s; }
        .hidden { display: none !important; }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1.1); opacity: 1; } }
        .pop-in { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
		.sub-mode-switch { background: #222; border: 1px solid #444; border-radius: 6px; display: flex; overflow: hidden; margin-top: 5px; }
		.sub-opt { padding: 6px 12px; font-size: 16px; color: #777; cursor: pointer; transition: all 0.2s; border-right: 1px solid #333; }
		.sub-opt:last-child { border-right: none; }
		.sub-opt:hover { background: #333; }
		.sub-opt.active { background: #3498db; color: white; }
		
    </style>
</head>
<body>
    <div id="viewport"></div>
    <div id="ui-layer">
        <div id="status">Listo</div>
        <div class="header">
            <div id="side-panel" class="interactive">
                <div class="mode-switch">
                    <div id="btn-mode-obj" class="mode-opt active">OBJETO</div>
                    <div id="btn-mode-edit" class="mode-opt">EDICI√ìN</div>
                </div>
				<div id="sub-mode-bar" class="sub-mode-switch hidden">
					<div id="sel-vertex" class="sub-opt active" title="V√©rtices">1 Punto</div>
					<div id="sel-edge" class="sub-opt" title="Bordes">2 Borde</div>
					<div id="sel-face" class="sub-opt" title="Caras">3 Cara</div>
				</div>
            </div>
            <div style="display: flex; gap: 8px;" class="interactive">
                <button id="btn-toggle-wire" class="btn-icon" style="background: #444;" title="Alternar Vista">üëÅÔ∏è</button>
                <div style="width:1px; background:#555; margin: 0 2px;"></div>
                <button id="btn-add">Ôºã Cubo</button>
                <button id="btn-export" class="btn-green">‚¨á GLB</button>
            </div>
        </div>
        
        <div id="action-container" class="interactive hidden" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none;">
             <button id="btn-connect-action" class="btn-action pop-in" style="pointer-events: auto;">‚ö° ACCI√ìN</button>
        </div>

        <div class="footer">
            <div class="transform-bar" id="transform-tools">
                <button id="mode-translate" class="active">Mover</button>
                <button id="mode-rotate">Rotar</button>
                <button id="mode-scale">Escalar</button>
                <div style="width:1px; background:#555; margin: 0 5px;"></div>
                <button id="btn-delete" class="btn-danger">üóë</button>
            </div>
            <div class="transform-bar hidden" id="edit-tools-bar">
                <button id="tool-select" class="active btn-tool">üëÜ</button>
                <button id="tool-cut" class="btn-tool" style="background:#d35400; color:white;">üî™</button>
                <button id="tool-connect" class="btn-tool" style="background:#8e44ad; color:white;">üîó</button>
				<button id="tool-extrude" class="btn-tool" style="background:#2ecc71; color:white;">E</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

class VVert {
    constructor(id, x, y, z) {
        this.id = id;
        this.x = x; this.y = y; this.z = z;
        this.handle = null; // Referencia visual (la bolita azul)
    }
}

class VFace {
    constructor(id, vertIds) {
        this.id = id;
        this.verts = vertIds; // Array de IDs [0, 1, 2, 3]
        this.selected = false;
        this.normal = new THREE.Vector3();
    }
}

class VirtualMesh {
    constructor() {
        this.verts = {}; // Diccionario de v√©rtices { id: VVert }
        this.faces = {}; // Diccionario de caras { id: VFace }
        this.vertCounter = 0;
        this.faceCounter = 0;
    }

    addVert(x, y, z) {
        const id = this.vertCounter++;
        this.verts[id] = new VVert(id, x, y, z);
        return id;
    }

    addFace(vertIds) {
        const id = this.faceCounter++;
        this.faces[id] = new VFace(id, vertIds);
        return id;
    }

extrudeFace(faceId, distance) {
        const face = this.faces[faceId];
        if(!face) return;

        // 1. Calcular direcci√≥n de extrusi√≥n (Normal)
        const p0 = this.verts[face.verts[0]];
        const p1 = this.verts[face.verts[1]];
        const p2 = this.verts[face.verts[2]];
        
        const vA = new THREE.Vector3(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
        const vB = new THREE.Vector3(p2.x - p0.x, p2.y - p0.y, p2.z - p0.z);
        const normal = new THREE.Vector3().crossVectors(vA, vB).normalize();
        const moveVec = normal.multiplyScalar(distance);

        // 2. Crear los NUEVOS v√©rtices (la "tapa" extruida)
        const oldVertIds = [...face.verts];
        const newVertIds = [];

        oldVertIds.forEach(vid => {
            const oldV = this.verts[vid];
            // Crear copia movida
            const newId = this.addVert(oldV.x + moveVec.x, oldV.y + moveVec.y, oldV.z + moveVec.z);
            newVertIds.push(newId);
        });

        // 3. Crear las caras laterales (Puentes)
        // Conecta: Old1 -> Old2 -> New2 -> New1
        for(let i = 0; i < oldVertIds.length; i++) {
            const nextI = (i + 1) % oldVertIds.length;
            
            const sideFaceVerts = [
                oldVertIds[i],
                oldVertIds[nextI],
                newVertIds[nextI], // Nota el orden para mantener la normal hacia afuera
                newVertIds[i]
            ];
            this.addFace(sideFaceVerts);
        }

        // 4. Mover la cara original a los nuevos v√©rtices (tapa frontal)
        face.verts = newVertIds;

        console.log("Extrusi√≥n completada. Caras totales:", Object.keys(this.faces).length);
    }

    // Convierte esta data abstracta en buffers reales de Three.js
    toBufferGeometry() {
        const positions = [];
        const indices = [];
        const tempVertMap = {}; // Map local ID -> Index Array

        let idxCounter = 0;

        // Aplanar v√©rtices y caras para Three.js
        // Nota: Esto es simplificado. En producci√≥n duplicamos v√©rtices para hard-edges (normales duras).
        
        Object.values(this.faces).forEach(face => {
            // Triangulaci√≥n b√°sica (Fan triangulation para n-gons)
            const vIds = face.verts;
            const rootIdx = idxCounter; // √çndice base local
            
            // A√±adir posiciones de esta cara
            vIds.forEach(vid => {
                const v = this.verts[vid];
                positions.push(v.x, v.y, v.z);
            });

            // Crear tri√°ngulos: 0,1,2 - 0,2,3 - 0,3,4...
            for(let i = 1; i < vIds.length - 1; i++) {
                indices.push(idxCounter, idxCounter + i, idxCounter + i + 1);
            }
            
            idxCounter += vIds.length;
        });

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setIndex(indices);
        geo.computeVertexNormals();
        return geo;
    }
	
	toJSON() {
        return {
            verts: this.verts,       // Guarda la lista de v√©rtices
            faces: this.faces,       // Guarda la lista de caras
            vertCounter: this.vertCounter,
            faceCounter: this.faceCounter
        };
    }

    // === NUEVO: DESERIALIZACI√ìN (CARGAR) ===
    static fromJSON(data) {
        const vm = new VirtualMesh();
        vm.vertCounter = data.vertCounter;
        vm.faceCounter = data.faceCounter;
        
        // Reconstruir V√©rtices (Reactiva la clase VVert)
        Object.keys(data.verts).forEach(key => {
            const v = data.verts[key];
            vm.verts[key] = new VVert(v.id, v.x, v.y, v.z);
        });

        // Reconstruir Caras (Reactiva la clase VFace)
        Object.keys(data.faces).forEach(key => {
            const f = data.faces[key];
            vm.faces[key] = new VFace(f.id, f.verts);
        });
        
        return vm;
    }
	
	
	
}
// --- FIN SISTEMA ---	

        class App {
            constructor() {
                this.state = {
                    mode: 'object', editTool: 'select', 
                    knifeStep: 0, 
                    isCutting: false, isTouching: false,
                    selectedObj: null, pointerData: { x:0, y:0, time:0, isGizmoDragging: false },
                    activeEdge: null, slideRuler: null, cutRatio: 0.0,
                    cutOptions: [],
                    dragStart: { x: 0, y: 0 },
                    multiSelection: [],
                    wireframeMode: 'clean',
                    userEdges: [],
					selectMode: 'vertex', 
					selectedGroup: [],    
					groupStartPos: [],    
					dragGroupOffsets: [], 
                };
                this.objects = []; this.handles = []; this.vertexMap = [];
				this.dummy = new THREE.Object3D(); 
				this.faceHighlightHelper = null;   
                this.wireframeHelper = null; 
                this.edgeHighlightHelper = null; this.cutPreviewHelper = null;
                this.connectionLine = null;

                this.raycaster = new THREE.Raycaster();
                this.raycaster.params.Line.threshold = 0.3; 

                this.initScene();
                this.initControls();
                this.initInteraction();
                this.initUI();
                this.addCube();
                this.renderer.setAnimationLoop(this.render.bind(this));
				this.virtualMesh = null; // A√±adir esto
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x222222);
                this.scene.add(new THREE.GridHelper(30, 30, 0x444444, 0x282828));
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.7)); 
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);

                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(5, 5, 5);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('viewport').appendChild(this.renderer.domElement);

                this.selectionGroup = new THREE.Group();
                this.scene.add(this.selectionGroup);

                const edgeMat = new THREE.LineBasicMaterial({ color: 0xffff00, depthTest: false, linewidth: 5 });
                this.edgeHighlightHelper = new THREE.LineSegments(new THREE.BufferGeometry(), edgeMat);
                this.edgeHighlightHelper.renderOrder = 9999;
                this.scene.add(this.edgeHighlightHelper);

                const cutMat = new THREE.LineBasicMaterial({ color: 0x00ff00, depthTest: false, transparent: false, linewidth: 3 });
                this.cutPreviewHelper = new THREE.LineSegments(new THREE.BufferGeometry(), cutMat);
                this.cutPreviewHelper.renderOrder = 9999;
                this.scene.add(this.cutPreviewHelper);

                const connMat = new THREE.LineBasicMaterial({ color: 0xffdd00, depthTest: false, linewidth: 3 });
                this.connectionLine = new THREE.Line(new THREE.BufferGeometry(), connMat);
                this.connectionLine.renderOrder = 9999;
                this.connectionLine.visible = false;
                this.scene.add(this.connectionLine);
				
				this.scene.add(this.dummy);
				
				const faceGeo = new THREE.BufferGeometry();
				const faceMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.4, side: THREE.DoubleSide, depthTest: false });
				this.faceHighlightHelper = new THREE.Mesh(faceGeo, faceMat);
				this.faceHighlightHelper.renderOrder = 9998;
				this.faceHighlightHelper.visible = false; 
				this.scene.add(this.faceHighlightHelper);
            }

            initControls() {
                this.orbit = new OrbitControls(this.camera, this.renderer.domElement);
                this.orbit.enableDamping = true;
                this.gizmo = new TransformControls(this.camera, this.renderer.domElement);
                this.scene.add(this.gizmo);
                
                this.gizmo.addEventListener('dragging-changed', (e) => {
				this.orbit.enabled = !e.value;
				this.state.pointerData.isGizmoDragging = e.value;
    
				if (e.value && this.state.selectedGroup.length > 1) {
				const center = this.dummy.position.clone();
				this.state.dragGroupOffsets = this.state.selectedGroup.map(h => {
				return new THREE.Vector3().subVectors(h.position, center);
				});
			}
		});

				this.gizmo.addEventListener('change', () => {
					if (this.state.mode === 'edit' && this.state.selectedGroup.length > 1 && this.state.pointerData.isGizmoDragging) {
						const currentDummyPos = this.dummy.position;
						
						this.state.selectedGroup.forEach((h, i) => {
							if (this.state.dragGroupOffsets[i]) {
								const offset = this.state.dragGroupOffsets[i];
								const newPos = currentDummyPos.clone().add(offset);
								h.position.copy(newPos);
							}
						});
						this.updateGeometryFromHandles();
					} 
					else if (this.state.mode === 'edit' && this.state.selectedObj) {
						this.updateGeometryFromHandles();
					}
				});
            }

            initInteraction() {
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('pointerdown', (e) => {
                    this.state.pointerData.x = e.clientX;
                    this.state.pointerData.y = e.clientY;
                    this.state.pointerData.time = Date.now();
                    this.state.isTouching = true;

                    if(this.state.mode === 'edit' && this.state.editTool === 'cut' && this.state.knifeStep === 1) {
                        this.state.isCutting = true;
                        this.state.dragStart = { x: e.clientX, y: e.clientY };
                        this.updateKnifeVisuals(e, 'cut_start');
                    }
                });

                canvas.addEventListener('pointermove', (e) => {
                    if(this.state.mode === 'edit' && this.state.editTool === 'cut' && this.state.isTouching) {
                        if (this.state.knifeStep === 0) {
                            this.updateKnifeVisuals(e, 'search');
                        }
                        else if (this.state.isCutting) {
                            this.updateKnifeVisuals(e, 'cut_move');
                        }
                    }
                });

                canvas.addEventListener('pointerup', (e) => {
                    this.state.isTouching = false;
                    if(this.state.pointerData.isGizmoDragging) return;
                    const dist = Math.hypot(e.clientX - this.state.pointerData.x, e.clientY - this.state.pointerData.y);

                    if (this.state.mode === 'edit' && this.state.editTool === 'cut') { 
                        if (this.state.knifeStep === 0) {
                            if (this.state.activeEdge) { 
                                this.updateKnifeVisuals(e, 'select');
                            }
                        }
                        else if (this.state.isCutting) {
                            this.updateKnifeVisuals(e, 'apply');
                            this.state.isCutting = false;
                        }
                        return; 
                    }
                    
                    if(dist < 10 && (Date.now() - this.state.pointerData.time) < 300) this.handleTap(e.clientX, e.clientY);
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            getPairId(id1, id2) {
                return (id1 < id2) ? `${id1}_${id2}` : `${id2}_${id1}`;
            }

            syncUserEdgesToMesh() {
                if(this.state.selectedObj) {
                    this.state.selectedObj.userData.userEdges = [...this.state.userEdges];
                }
            }

            addUserEdge(id1, id2) {
                const pair = this.getPairId(id1, id2);
                if (!this.state.userEdges.includes(pair)) {
                    this.state.userEdges.push(pair);
                    this.syncUserEdgesToMesh(); 
                }
            }

            removeUserEdge(id1, id2) {
                const pair = this.getPairId(id1, id2);
                const idx = this.state.userEdges.indexOf(pair);
                if (idx !== -1) {
                    this.state.userEdges.splice(idx, 1);
                    this.syncUserEdgesToMesh();
                }
            }

            hasUserEdge(id1, id2) {
                const pair = this.getPairId(id1, id2);
                return this.state.userEdges.includes(pair);
            }

            toggleConnectSelection(handle) {
                const idx = this.state.multiSelection.indexOf(handle);
                if (idx > -1) {
                    handle.children[0].material.color.setHex(0xff3333); 
                    this.state.multiSelection.splice(idx, 1);
                } else {
                    if (this.state.multiSelection.length >= 2) {
                        const old = this.state.multiSelection.shift();
                        old.children[0].material.color.setHex(0xff3333);
                    }
                    handle.children[0].material.color.setHex(0x2ecc71);
                    this.state.multiSelection.push(handle);
                }

                if (this.state.multiSelection.length === 2) {
                    const h1 = this.state.multiSelection[0];
                    const h2 = this.state.multiSelection[1];
                    const id1 = this.handles.indexOf(h1);
                    const id2 = this.handles.indexOf(h2);

                    const exists = this.hasUserEdge(id1, id2);
                    const btn = document.getElementById('btn-connect-action');
                    
                    if (exists) {
                        btn.innerText = "‚ö° DISOLVER";
                        btn.style.background = "#e74c3c"; 
                    } else {
                        btn.innerText = "‚ö° CONECTAR";
                        btn.style.background = "#f1c40f"; 
                    }

                    const pts = [h1.position, h2.position];
                    this.connectionLine.geometry.setFromPoints(pts);
                    this.connectionLine.visible = true;
                    document.getElementById('action-container').classList.remove('hidden');
                } else {
                    this.connectionLine.visible = false;
                    document.getElementById('action-container').classList.add('hidden');
                }
            }

            performConnection() {
                if (this.state.multiSelection.length !== 2) return;
                const mesh = this.state.selectedObj; if (!mesh) return;

                const h1 = this.state.multiSelection[0];
                const h2 = this.state.multiSelection[1];
                const id1 = this.handles.indexOf(h1);
                const id2 = this.handles.indexOf(h2);

                if (this.hasUserEdge(id1, id2)) {
                    this.removeUserEdge(id1, id2); 
                    document.getElementById('status').innerText = "L√≠nea Disuelta (Visual)";
                } else {
                    this.addUserEdge(id1, id2); 
                    
                    const vIndices1 = []; const vIndices2 = [];
                    this.vertexMap.forEach((handleIdx, vIdx) => {
                        if (handleIdx === id1) vIndices1.push(vIdx);
                        if (handleIdx === id2) vIndices2.push(vIdx);
                    });

                    if (vIndices1.length > 0 && vIndices2.length > 0) {
                        const indexAttr = mesh.geometry.index;
                        const indices = indexAttr.array;
                        const isG1 = (i) => vIndices1.includes(i);
                        const isG2 = (i) => vIndices2.includes(i);
                        
                        let success = false;
                        const trisP1 = [];
                        for(let i=0; i<indices.length; i+=3) {
                            if(isG1(indices[i]) || isG1(indices[i+1]) || isG1(indices[i+2])) trisP1.push(i);
                        }

                        const replaceInTri = (baseIdx, oldVal, newVal) => {
                            if(indices[baseIdx] == oldVal) indices[baseIdx] = newVal;
                            else if(indices[baseIdx+1] == oldVal) indices[baseIdx+1] = newVal;
                            else if(indices[baseIdx+2] == oldVal) indices[baseIdx+2] = newVal;
                        };

                        for (let t1 of trisP1) {
                            if(success) break;
                            const vA = [indices[t1], indices[t1+1], indices[t1+2]];
                            for(let t2=0; t2<indices.length; t2+=3) {
                                if(t1 === t2) continue;
                                const vB = [indices[t2], indices[t2+1], indices[t2+2]];
                                const shared = vA.filter(v => vB.includes(v));
                                if(shared.length === 2) {
                                    const uniqueA = vA.find(v => !shared.includes(v));
                                    const uniqueB = vB.find(v => !shared.includes(v));
                                    const p1InShared = shared.some(v => isG1(v));
                                    const p2InShared = shared.some(v => isG2(v));
                                    
                                    if(p1InShared && p2InShared) {
                                        success = true; break; 
                                    }

                                    const isConnectCase = (isG1(uniqueA) && isG2(uniqueB)) || (isG1(uniqueB) && isG2(uniqueA));
                                    if(isConnectCase) {
                                        const s0 = shared[0]; const s1 = shared[1];
                                        replaceInTri(t1, s1, uniqueB); replaceInTri(t2, s0, uniqueA);
                                        success = true; document.getElementById('status').innerText = "Conexi√≥n Creada"; break;
                                    }
                                }
                            }
                        }
                        if(success) { mesh.geometry.index.needsUpdate = true; mesh.geometry.computeVertexNormals(); }
                    }
                }

                this.setupDirectWireframe(mesh);

                this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333));
                this.state.multiSelection = [];
                this.connectionLine.visible = false;
                document.getElementById('action-container').classList.add('hidden');
            }

            updateWireframeRealtime() {
                const mesh = this.state.selectedObj; if(!mesh) return;
                
                if(this.wireframeHelper) { 
                    mesh.remove(this.wireframeHelper); 
                    if(this.wireframeHelper.geometry) this.wireframeHelper.geometry.dispose();
                    this.wireframeHelper = null;
                }
                
                let geometry;
                if (this.state.wireframeMode === 'full') {
                    geometry = new THREE.WireframeGeometry(mesh.geometry);
                } else {
                    const grid = this.getStructuredHandles(mesh);
                    if (!grid) return;
                    
                    const segs = mesh.userData.segments;
                    const nx = grid.length; 
                    const ny = grid[0].length; 
                    const nz = grid[0][0].length;
                    const newPoints = [];

                    const getPos = (i,j,k) => {
                        const p = grid[i][j][k].position.clone();
                        mesh.worldToLocal(p);
                        return p;
                    };

                    for(let i=0; i<nx; i++) {
                        for(let j=0; j<ny; j++) {
                            for(let k=0; k<nz; k++) {
                                const p = getPos(i,j,k);
                                if (i < nx - 1) { const px = getPos(i+1, j, k); newPoints.push(p.x, p.y, p.z, px.x, px.y, px.z); }
                                if (j < ny - 1) { const py = getPos(i, j+1, k); newPoints.push(p.x, p.y, p.z, py.x, py.y, py.z); }
                                if (k < nz - 1) { const pz = getPos(i, j, k+1); newPoints.push(p.x, p.y, p.z, pz.x, pz.y, pz.z); }
                            }
                        }
                    }

                    this.state.userEdges.forEach(pairStr => {
                        const parts = pairStr.split('_');
                        const h1 = this.handles[parseInt(parts[0])];
                        const h2 = this.handles[parseInt(parts[1])];
                        if (h1 && h2) {
                            const p1 = h1.position.clone(); mesh.worldToLocal(p1);
                            const p2 = h2.position.clone(); mesh.worldToLocal(p2);
                            newPoints.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
                        }
                    });

                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(newPoints, 3));
                }

                const mat = new THREE.LineBasicMaterial({ color: 0xffaa00, depthTest: false, opacity: 1, transparent: false });
                this.wireframeHelper = new THREE.LineSegments(geometry, mat);
                this.wireframeHelper.renderOrder = 999;
                mesh.add(this.wireframeHelper);
            }
			
			toggleWireframeMode() {
				// Alternar entre modos
				if (this.state.wireframeMode === 'clean') {
				this.state.wireframeMode = 'full';
				document.getElementById('status').innerText = "Vista: Alambre Completo";
    } else {
        this.state.wireframeMode = 'clean';
        document.getElementById('status').innerText = "Vista: Limpia";
    }
    
    // Forzar actualizaci√≥n visual
    if (this.state.selectedObj) {
        this.updateWireframeRealtime();
    }
}

            updateKnifeVisuals(mouseEvent, phase) {
                if(!this.state.selectedObj) return;
                const rect = this.renderer.domElement.getBoundingClientRect();
                
                const getScreenPos = (vec3) => {
                    const v = vec3.clone().project(this.camera);
                    return new THREE.Vector2(
                        (v.x * .5 + .5) * rect.width + rect.left,
                        -(v.y * .5 - .5) * rect.height + rect.top
                    );
                };

                const mouseNDS = new THREE.Vector2(
                    ((mouseEvent.clientX - rect.left)/rect.width)*2-1, 
                    -((mouseEvent.clientY - rect.top)/rect.height)*2+1
                );
                const mousePx = new THREE.Vector2(mouseEvent.clientX, mouseEvent.clientY);

                if (phase === 'search') {
                    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(mouseNDS, this.camera);
                    const edge = this.findClosestEdge(raycaster);
                    
                    if(edge) {
                        this.state.activeEdge = edge;
                        const fullLinePoints = this.getFullEdgeLine(edge);
                        this.edgeHighlightHelper.geometry.setFromPoints(fullLinePoints);
                        this.edgeHighlightHelper.material.color.setHex(0xffff00); 
                        this.edgeHighlightHelper.visible = true;
                        this.cutPreviewHelper.visible = false;
                        document.getElementById('status').innerText = "Loop Detectado";
                    } else {
                        this.edgeHighlightHelper.visible = false;
                        this.cutPreviewHelper.visible = false;
                        this.state.activeEdge = null;
                        document.getElementById('status').innerText = "Cuchillo: Selecciona un borde";
                    }
                }
                
                else if (phase === 'select') {
                    if (this.state.activeEdge) {
                        this.state.knifeStep = 1;
                        this.edgeHighlightHelper.material.color.setHex(0x00ff00); 
                        
                        this.cutPreviewHelper.visible = false; 
                        
                        document.getElementById('status').innerText = "Arrastra para ajustar";

                        const edge = this.state.activeEdge;
                        const grid = this.getStructuredHandles(this.state.selectedObj);
                        const { axis, x, y, z } = edge;
                        const segs = this.state.selectedObj.userData.segments;
                        const options = [];

                        if (axis === 'y') {
                            options.push({ start: grid[0][y][z].position, end: grid[segs.x][y][z].position, axis: 'x', range: segs.x });
                            options.push({ start: grid[x][y][0].position, end: grid[x][y][segs.z].position, axis: 'z', range: segs.z });
                        }
                        else if (axis === 'x' || axis === 'z') {
                            options.push({ start: grid[x][0][z].position, end: grid[x][segs.y][z].position, axis: 'y', range: segs.y });
                        }
                        this.state.cutOptions = options;
                    }
                }

                else if (phase === 'cut_start' || phase === 'cut_move') {
                    if (phase === 'cut_start') this.state.knifeStep = 2;

                    let bestOption = null, bestDist = Infinity;
                    const options = this.state.cutOptions;

                    if (!options || options.length === 0) return;

                    options.forEach(opt => {
                        const p1 = getScreenPos(opt.start);
                        const p2 = getScreenPos(opt.end);
                        const l2 = p1.distanceToSquared(p2);
                        if (l2 < 1) return;
                        
                        let t = ((mousePx.x - p1.x) * (p2.x - p1.x) + (mousePx.y - p1.y) * (p2.y - p1.y)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        const proj = new THREE.Vector2().copy(p1).lerp(p2, t);
                        const d = mousePx.distanceTo(proj);
                        
                        if (d < bestDist) { bestDist = d; bestOption = opt; }
                    });

                    if (!bestOption) bestOption = (this.state.dragInfo && this.state.dragInfo.ruler) || options[0];

                    if (!this.state.dragInfo || this.state.dragInfo.ruler !== bestOption) {
                        
                        const p1 = getScreenPos(bestOption.start);
                        const p2 = getScreenPos(bestOption.end);
                        const lineVec = new THREE.Vector2().subVectors(p2, p1);
                        const screenLength = lineVec.length();
                        
                        let currentAbsT = mousePx.clone().sub(p1).dot(lineVec) / (screenLength * screenLength);
                        currentAbsT = Math.max(0, Math.min(1, currentAbsT));

                        this.state.dragInfo = {
                            startMouse: mousePx.clone(),
                            startT: currentAbsT,
                            lineVecNorm: lineVec.normalize(),
                            virtualLength: 400,             
                            ruler: bestOption
                        };
                        
                        this.cutPreviewHelper.visible = true;
                    }

                    const drag = this.state.dragInfo;
                    const delta = new THREE.Vector2().subVectors(mousePx, drag.startMouse);
                    const moveProj = delta.dot(drag.lineVecNorm);
                    
                    let newT = drag.startT + (moveProj / drag.virtualLength);
                    newT = Math.max(0.01, Math.min(0.99, newT));
                    
                    this.updateCutVisualsInternal(newT, drag.ruler);
                    this.state.slideRuler = drag.ruler;
                }

                else if (phase === 'apply') {
                    if (this.cutPreviewHelper.visible && this.state.slideRuler) {
                        const ruler = this.state.slideRuler;
                        const totalSegs = ruler.range;
                        const globalVal = this.state.cutRatio * totalSegs;
                        const index = Math.min(Math.floor(globalVal), totalSegs - 1);
                        const localRatio = Math.max(0.01, Math.min(0.99, globalVal - index));
                        this.applyCut(ruler.axis, index, localRatio);
                    }
                    this.resetKnifeTool();
                    this.state.dragInfo = null;
                }
            }

            updateCutVisualsInternal(t, ruler) {
                this.state.cutRatio = t;
                const totalSegs = ruler.range;
                const globalVal = t * totalSegs;
                const index = Math.floor(globalVal);
                const localRatio = globalVal - index;
                const safeIndex = Math.min(index, totalSegs - 1);
                const safeRatio = (index >= totalSegs) ? 0.99 : localRatio;
                this.drawLoopPreview(ruler.axis, safeIndex, safeRatio);
            }

            setupDirectWireframe(mesh) {
				// 1. Limpieza previa
				if(this.wireframeHelper) { 
					mesh.remove(this.wireframeHelper); 
					if(this.wireframeHelper.geometry) this.wireframeHelper.geometry.dispose(); 
					this.wireframeHelper = null; 
				}
			
				// Solo funciona si tenemos datos l√≥gicos
				if (!this.virtualMesh) return;
			
				const positions = [];
				const processedEdges = new Set(); // Para no dibujar la misma l√≠nea dos veces
			
				// 2. Recorrer cada cara virtual para extraer bordes
				Object.values(this.virtualMesh.faces).forEach(face => {
					const verts = face.verts;
					for (let i = 0; i < verts.length; i++) {
						const id1 = verts[i];
						const id2 = verts[(i + 1) % verts.length]; // Conectar con el siguiente
						
						// Crear una clave √∫nica para el borde (ej: "5_12") ordenando menor_mayor
						const key = (id1 < id2) ? `${id1}_${id2}` : `${id2}_${id1}`;
						
						if (!processedEdges.has(key)) {
							processedEdges.add(key); // Marcar como dibujado
							
							// Obtener posiciones LOCALES (porque el helper ser√° hijo del mesh)
							const v1 = this.virtualMesh.verts[id1];
							const v2 = this.virtualMesh.verts[id2];
							
							positions.push(v1.x, v1.y, v1.z);
							positions.push(v2.x, v2.y, v2.z);
						}
					}
				});
			
				// 3. Crear Geometr√≠a de L√≠neas
				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
			
				// 4. Material "No-XRay"
				// depthTest: true hace que las l√≠neas se oculten detr√°s del objeto s√≥lido
				const material = new THREE.LineBasicMaterial({ 
					color: 0xff5500, // Naranja Blender
					depthTest: true, 
					opacity: 1
				});
				
				this.wireframeHelper = new THREE.LineSegments(geometry, material);
				
				// IMPORTANTE: Para evitar el "Z-Fighting" (parpadeo de l√≠neas), 
				// aseg√∫rate de que tu material del objeto tenga polygonOffset.
				// Si usas el material azul por defecto del c√≥digo anterior, ya lo tiene.
				
				mesh.add(this.wireframeHelper);
			}

            resetKnifeTool() {
                this.state.knifeStep = 0; this.state.activeEdge = null; this.state.isCutting = false;
                this.edgeHighlightHelper.visible = false; this.cutPreviewHelper.visible = false;
                this.edgeHighlightHelper.material.color.setHex(0xffff00); document.getElementById('status').innerText = "Cuchillo: Selecciona un borde";
            }

            applyCut(axis, index, ratio) {
                const mesh = this.state.selectedObj; 
                if(!mesh) return;

                const grid = this.getStructuredHandles(mesh);
                if (!grid) {
                    console.error("Error: No se pudo leer la estructura del objeto.");
                    return;
                }

                const segs = mesh.userData.segments;
                const old_nx = segs.x + 1, old_ny = segs.y + 1, old_nz = segs.z + 1;
                const newPositions = [];
                const lerpHandles = (h1, h2, t) => h1.position.clone().lerp(h2.position.clone(), t);

                try {
                    if(axis === 'x') { 
                        for(let i=0; i < old_nx; i++) { 
                            for(let j=0; j<old_ny; j++) for(let k=0; k<old_nz; k++) {
                                if(grid[i][j][k]) newPositions.push(grid[i][j][k].position.clone());
                                else newPositions.push(new THREE.Vector3()); 
                            }
                            if(i === index) {
                                for(let j=0; j<old_ny; j++) for(let k=0; k<old_nz; k++) {
                                    if(grid[i][j][k] && grid[i+1][j][k]) newPositions.push(lerpHandles(grid[i][j][k], grid[i+1][j][k], ratio));
                                    else newPositions.push(new THREE.Vector3());
                                }
                            }
                        } segs.x++; 
                    } 
                    else if(axis === 'y') { 
                        for(let i=0; i<old_nx; i++) { 
                            for(let j=0; j<old_ny; j++) { 
                                for(let k=0; k<old_nz; k++) {
                                    if(grid[i][j][k]) newPositions.push(grid[i][j][k].position.clone());
                                    else newPositions.push(new THREE.Vector3());
                                }
                                if(j === index) {
                                    for(let k=0; k<old_nz; k++) {
                                        if(grid[i][j][k] && grid[i][j+1][k]) newPositions.push(lerpHandles(grid[i][j][k], grid[i][j+1][k], ratio));
                                        else newPositions.push(new THREE.Vector3());
                                    }
                                }
                            } 
                        } segs.y++; 
                    }
                    else if(axis === 'z') { 
                        for(let i=0; i<old_nx; i++) { 
                            for(let j=0; j<old_ny; j++) { 
                                for(let k=0; k<old_nz; k++) { 
                                    if(grid[i][j][k]) newPositions.push(grid[i][j][k].position.clone());
                                    else newPositions.push(new THREE.Vector3());
                                    
                                    if(k === index) {
                                        if(grid[i][j][k] && grid[i][j][k+1]) newPositions.push(lerpHandles(grid[i][j][k], grid[i][j][k+1], ratio));
                                        else newPositions.push(new THREE.Vector3());
                                    }
                                } 
                            } 
                        } segs.z++; 
                    }
                } catch (e) {
                    console.error("Error calculando corte:", e);
                    return; 
                }

                const newGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5, segs.x, segs.y, segs.z);
                mesh.geometry.dispose(); 
                mesh.geometry = newGeo;
                
                mesh.userData.gridInfo = null;
                
                this.enterEditMode(true); 

                const currentStructured = this.getStructuredHandles(mesh);
                const targetOrder = [];
                const n_nx = segs.x + 1, n_ny = segs.y + 1, n_nz = segs.z + 1;

                if(axis === 'x') for(let i=0; i<n_nx; i++) for(let j=0; j<n_ny; j++) for(let k=0; k<n_nz; k++) targetOrder.push(currentStructured[i][j][k]);
                else if(axis === 'y') for(let i=0; i<n_nx; i++) for(let j=0; j<n_ny; j++) for(let k=0; k<n_nz; k++) targetOrder.push(currentStructured[i][j][k]);
                else for(let i=0; i<n_nx; i++) for(let j=0; j<n_ny; j++) for(let k=0; k<n_nz; k++) targetOrder.push(currentStructured[i][j][k]);

                for(let i=0; i<targetOrder.length; i++) {
                    if(targetOrder[i] && newPositions[i]) {
                        targetOrder[i].position.copy(newPositions[i]);
                    }
                }
                this.updateGeometryFromHandles();
            }

            enterEditMode(resetPositions = true) {
				const mesh = this.state.selectedObj; 
				if (!mesh) return;
			
				this.state.mode = 'edit';
				this.gizmo.detach();
				this.clearHandles(); 
			
				// Forzar actualizaci√≥n de matrices para evitar errores de posici√≥n
				mesh.updateMatrixWorld(true);
			
				// L√ìGICA DE CARGA INTELIGENTE
				// 1. ¬øTiene datos guardados? -> C√°rgalos
				if (mesh.userData.vmData) {
					console.log("Restaurando malla modificada...");
					this.virtualMesh = VirtualMesh.fromJSON(mesh.userData.vmData);
				} 
				// 2. ¬øNo tiene datos? -> Crea la inicial (Bounding Box)
				else if (!this.virtualMesh || resetPositions) {
					console.log("Creando malla inicial...");
					this.virtualMesh = new VirtualMesh();
					
					// ... (Aqu√≠ va tu c√≥digo de BoundingBox que hicimos en el paso anterior) ...
					const geo = mesh.geometry;
					geo.computeBoundingBox();
					const box = geo.boundingBox;
					const rx = (box.max.x - box.min.x) / 2;
					const ry = (box.max.y - box.min.y) / 2;
					const rz = (box.max.z - box.min.z) / 2;
					
					// ... (Tus addVert y addFace iniciales) ...
					const v0 = this.virtualMesh.addVert(-rx, -ry,  rz);
					const v1 = this.virtualMesh.addVert( rx, -ry,  rz);
					const v2 = this.virtualMesh.addVert(-rx,  ry,  rz);
					const v3 = this.virtualMesh.addVert( rx,  ry,  rz);
					const v4 = this.virtualMesh.addVert(-rx, -ry, -rz);
					const v5 = this.virtualMesh.addVert( rx, -ry, -rz);
					const v6 = this.virtualMesh.addVert(-rx,  ry, -rz);
					const v7 = this.virtualMesh.addVert( rx,  ry, -rz);
			
					this.virtualMesh.addFace([v0, v1, v3, v2]);
					this.virtualMesh.addFace([v5, v4, v6, v7]);
					this.virtualMesh.addFace([v4, v0, v2, v6]);
					this.virtualMesh.addFace([v1, v5, v7, v3]);
					this.virtualMesh.addFace([v2, v3, v7, v6]);
					this.virtualMesh.addFace([v4, v5, v1, v0]);
				}
			
				// 3. Crear Handles (Esto sigue igual, usando requestAnimationFrame por seguridad)
				requestAnimationFrame(() => {
					Object.values(this.virtualMesh.verts).forEach(v => {
						const localPos = new THREE.Vector3(v.x, v.y, v.z);
						const worldPos = localPos.applyMatrix4(mesh.matrixWorld);
						const worldPos = localPos.applyMatrix4(mesh.matrixWorld);
			
						const handle = this.createHandleMesh(worldPos);
						handle.userData.virtId = v.id; 
						this.handles.push(handle);
						this.scene.add(handle);
						v.handle = handle; 
					});
								
					this.setupDirectWireframe(mesh);
					// Render extra para asegurar que se vean
					if(this.renderer && this.scene && this.camera) {
						this.renderer.render(this.scene, this.camera);
					}
				});

				document.getElementById('status').innerText = "Modo Edici√≥n: Activo";
				
				// UI
				document.getElementById('sub-mode-bar').classList.remove('hidden');
				document.getElementById('edit-tools-bar').classList.remove('hidden');
				document.getElementById('transform-tools').classList.add('hidden');
			}

            cacheGridIndices(mesh) {
                const segs = mesh.userData.segments;
                const nx = segs.x + 1;
                const ny = segs.y + 1;
                const nz = segs.z + 1;

                mesh.geometry.computeBoundingBox();
                const min = mesh.geometry.boundingBox.min;
                const max = mesh.geometry.boundingBox.max;
                const size = new THREE.Vector3().subVectors(max, min);

                if(size.x === 0) size.x = 1;
                if(size.y === 0) size.y = 1;
                if(size.z === 0) size.z = 1;

                if(!mesh.userData.gridInfo) mesh.userData.gridInfo = [];

                this.handles.forEach((h, hIdx) => {
                    const localPos = h.position.clone();
                    mesh.worldToLocal(localPos);

                    const percentX = (localPos.x - min.x) / size.x;
                    const percentY = (localPos.y - min.y) / size.y;
                    const percentZ = (localPos.z - min.z) / size.z;

                    const ix = Math.max(0, Math.min(nx - 1, Math.round(percentX * segs.x)));
                    const iy = Math.max(0, Math.min(ny - 1, Math.round(percentY * segs.y)));
                    const iz = Math.max(0, Math.min(nz - 1, Math.round(percentZ * segs.z)));

                    const vIdx = this.vertexMap.indexOf(hIdx);
                    if (vIdx !== -1) {
                         mesh.userData.gridInfo[vIdx] = { x: ix, y: iy, z: iz };
                    }
                });
            }
			
			generateSpatialGrid(mesh) {
                const segs = mesh.userData.segments;
                const nx = segs.x + 1;
                const ny = segs.y + 1;
                const nz = segs.z + 1;

                const items = this.handles.map(h => {
                    const localPos = h.position.clone();
                    mesh.worldToLocal(localPos);
                    return { h, x: localPos.x, y: localPos.y, z: localPos.z };
                });

                const EPSILON = 0.001; 

                const gapSort = (arr, prop) => {
                    arr.sort((a,b) => a[prop] - b[prop]); 
                    const buckets = [];
                    if (arr.length === 0) return buckets;
                    let currentBucket = [arr[0]];
                    buckets.push(currentBucket);
                    for (let i = 1; i < arr.length; i++) {
                        if (Math.abs(arr[i][prop] - arr[i-1][prop]) > EPSILON) {
                            currentBucket = [arr[i]];
                            buckets.push(currentBucket);
                        } else {
                            currentBucket.push(arr[i]);
                        }
                    }
                    return buckets;
                };

                const grid = [];
                const xBuckets = gapSort(items, 'x');
                
                if(xBuckets.length > nx) {
                     xBuckets.sort((a,b) => b.length - a.length);
                     const selected = xBuckets.slice(0, nx).sort((a,b) => a[0].x - b[0].x);
                     xBuckets.length = 0; xBuckets.push(...selected);
                }
                
                for(let i=0; i<nx; i++) {
                    grid[i] = [];
                    const xItems = xBuckets[i] || xBuckets[xBuckets.length-1]; 
                    
                    const yBuckets = gapSort(xItems, 'y');
                    
                    if(yBuckets.length > ny) {
                         yBuckets.sort((a,b) => b.length - a.length);
                         const selected = yBuckets.slice(0, ny).sort((a,b) => a[0].y - b[0].y);
                         yBuckets.length = 0; yBuckets.push(...selected);
                    }

                    for(let j=0; j<ny; j++) {
                        const yItems = yBuckets[j] || yBuckets[yBuckets.length-1]; 
                        
                        yItems.sort((a,b) => a.z - b.z);

                        grid[i][j] = [];
                        for(let k=0; k<nz; k++) {
                            const item = yItems[k] || yItems[yItems.length-1]; 
                            grid[i][j][k] = item.h;
                        }
                    }
                }
                return grid;
            }

            getStructuredHandles(mesh) {
                if (mesh.userData.gridInfo && this.vertexMap.length > 0) {
                    const segs = mesh.userData.segments;
                    const nx = segs.x + 1, ny = segs.y + 1, nz = segs.z + 1;
                    
                    const grid = Array(nx).fill().map(() => Array(ny).fill().map(() => Array(nz).fill(null)));
                    
                    let dataCount = 0;
                    
                    this.handles.forEach((h, hIdx) => {
                        const vIdx = this.vertexMap.indexOf(hIdx);
                        if(vIdx !== -1 && mesh.userData.gridInfo[vIdx]) {
                            const {x, y, z} = mesh.userData.gridInfo[vIdx];
                            if(x < nx && y < ny && z < nz) {
                                grid[x][y][z] = h;
                                dataCount++;
                            }
                        }
                    });

                    if (dataCount > 0) return grid;
                }
                
                this.cacheGridIndices(mesh);
                return this.getStructuredHandles(mesh);
            }
			
            exitEditMode() {
                this.state.mode = 'object'; this.state.editTool = 'select'; 
                this.resetKnifeTool(); this.orbit.enabled = true;
                this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333));
                this.state.multiSelection = [];
                this.connectionLine.visible = false;
                document.getElementById('action-container').classList.add('hidden');
                
                document.getElementById('tool-select').click();
                this.clearHandles(); 
                if(this.wireframeHelper) { this.state.selectedObj.remove(this.wireframeHelper); this.wireframeHelper = null; }
                
                this.state.userEdges = []; 

                this.gizmo.detach();
				document.getElementById('sub-mode-bar').classList.add('hidden');
                document.getElementById('edit-tools-bar').classList.add('hidden');
                document.getElementById('transform-tools').classList.remove('hidden');
                if(this.state.selectedObj) this.gizmo.attach(this.state.selectedObj);
                document.getElementById('status').innerText = "Modo Objeto";
            }

            clearHandles() { this.handles.forEach(h => { if(h.parent) h.parent.remove(h); }); this.handles = []; this.vertexMap = []; }
            selectObject(mesh) { this.state.selectedObj = mesh; if(mesh) { mesh.material.emissive.setHex(0x333333); if(this.state.mode === 'object') this.gizmo.attach(mesh); } else { this.gizmo.detach(); } }
            
			// ============================================
			// FUNCI√ìN TAP BLINDADA (SOLUCI√ìN AL BUG)
			// ============================================
			handleTap(x, y) { 
				const rect = this.renderer.domElement.getBoundingClientRect(); 
				const mouse = new THREE.Vector2(((x-rect.left)/rect.width)*2-1, -((y-rect.top)/rect.height)*2+1); 
				this.raycaster.setFromCamera(mouse, this.camera); 
				const statusLabel = document.getElementById('status'); 
			
				// 1. MODO OBJETO (Sin cambios)
				if (this.state.mode === 'object') { 
					const hits = this.raycaster.intersectObjects(this.objects); 
					if (hits.length > 0) { this.selectObject(hits[0].object); statusLabel.innerText = "Objeto Seleccionado"; } 
					else { this.selectObject(null); statusLabel.innerText = "Modo Objeto"; } 
					return; 
				} 
			
				// 2. MODO EDICI√ìN
				this.clearSelectionVisuals();
				
				// *** PASO CR√çTICO: Desactivar Gizmo POR DEFECTO ***
				// Esto asegura que si tocas el aire o la cara del cubo sin tocar un componente v√°lido,
				// el gizmo se apaga y NO selecciona el objeto principal.
				this.gizmo.detach();
			
				if (this.state.editTool === 'select') {
					
					// SUB-MODO: V√âRTICES (REEMPLAZAR ESTE BLOQUE)
					if (this.state.selectMode === 'vertex') {
						const targets = [...this.handles];
				
						// 1. PASO DE OCLUSI√ìN: ¬øQu√© tan lejos est√° la pared visible?
						const meshHits = this.raycaster.intersectObject(this.state.selectedObj);
						let visibleDistanceLimit = Infinity;
						
						// Si golpeamos el objeto, definimos el l√≠mite de visi√≥n.
						// Le damos +0.15 de margen porque los handles (esferas) sobresalen un poco de la superficie.
						if (meshHits.length > 0) {
							visibleDistanceLimit = meshHits[0].distance + 0.15;
						}
				
						// 2. Intersectamos todos los handles
						const hits = this.raycaster.intersectObjects(targets, true);
						
						// 3. FILTRO MAESTRO: Ignorar handles que est√°n detr√°s de la pared
						// Solo aceptamos hits cuya distancia sea menor al l√≠mite visible
						const visibleHits = hits.filter(h => h.distance < visibleDistanceLimit);
				
						// 4. Validar que sea un handle real
						const validHit = visibleHits.find(h => {
							return this.handles.includes(h.object) || (h.object.parent && this.handles.includes(h.object.parent));
						});
				
						if (validHit) {
							const handle = this.handles.includes(validHit.object) ? validHit.object : validHit.object.parent;
							this.setSelection([handle], "V√©rtice Seleccionado");
						} 
						// Si no hay hit v√°lido visible, el gizmo se queda apagado (detach).
					} 
					
					// REEMPLAZAR BLOQUE 'edge'
					else if (this.state.selectMode === 'edge') {
						const edgeData = this.findClosestEdge(this.raycaster);
						if (edgeData) {
							// Ahora edgeData tiene .ids (IDs virtuales) y .points (Vector3)
							// Necesitamos encontrar los handles visuales para seleccionarlos
							const h1 = this.virtualMesh.verts[edgeData.ids[0]].handle;
							const h2 = this.virtualMesh.verts[edgeData.ids[1]].handle;
							
							if(h1 && h2) {
								this.setSelection([h1, h2], "Borde Seleccionado");
								this.edgeHighlightHelper.geometry.setFromPoints(edgeData.points);
								this.edgeHighlightHelper.visible = true;
							}
						}
					}
			
					// REEMPLAZAR BLOQUE 'face'
					else if (this.state.selectMode === 'face') {
						// findClosestFace ahora devuelve un array de handles directamente y guarda this.state.selectedFaceId
						const faceHandles = this.findClosestFace(this.raycaster);
						if (faceHandles) {
							this.setSelection(faceHandles, "Cara Seleccionada");
							
							// Dibujar el highlight (cuadrado rojo/naranja)
							// Triangulamos visualmente para el helper (Fan triangulation)
							const pts = [];
							const center = new THREE.Vector3();
							faceHandles.forEach(h => center.add(h.position));
							center.divideScalar(faceHandles.length);
					
							// Crear tri√°ngulos visuales para el highlight
							for(let i=0; i<faceHandles.length; i++) {
								pts.push(faceHandles[i].position.x, faceHandles[i].position.y, faceHandles[i].position.z);
								pts.push(faceHandles[(i+1)%faceHandles.length].position.x, faceHandles[(i+1)%faceHandles.length].position.y, faceHandles[(i+1)%faceHandles.length].position.z);
								pts.push(center.x, center.y, center.z);
							}
					
							this.faceHighlightHelper.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
							this.faceHighlightHelper.visible = true;
						}
					}
					return;
				}
			}	
	
					updateGeometryFromHandles() { 
						if (!this.state.selectedObj || !this.virtualMesh) return; 
					
						// 1. Calcular la matriz inversa (Mundo -> Local)
						const inverseMatrix = this.state.selectedObj.matrixWorld.clone().invert();
					
						// 2. SINCRONIZAR: De Handles (Mundo) -> VirtualMesh (Local)
						Object.values(this.virtualMesh.verts).forEach(v => {
							if(v.handle) {
								// Tomamos la posici√≥n visual actual (Mundo)
								const worldPos = v.handle.position.clone();
								
								// La convertimos a local relativo al objeto
								const localPos = worldPos.applyMatrix4(inverseMatrix);
					
								// Guardamos el dato local
								v.x = localPos.x;
								v.y = localPos.y;
								v.z = localPos.z;
							}
						});
					
						// 3. REGENERAR GEOMETR√çA (Esto usa los datos locales, as√≠ que ya est√° bien)
						const newGeo = this.virtualMesh.toBufferGeometry();
						
						this.state.selectedObj.geometry.dispose();
						this.state.selectedObj.geometry = newGeo;
						
						if (this.state.mode === 'edit') {
							this.setupDirectWireframe(this.state.selectedObj);
						}
						
						// === NUEVO: GUARDAR EN LA MOCHILA DEL OBJETO ===
						// Esto asegura que si sales y vuelves, la data est√© ah√≠.
						this.state.selectedObj.userData.vmData = this.virtualMesh.toJSON();
					}         
		 
            createHandleMesh(pos) { const hitGeo = new THREE.SphereGeometry(0.15, 8, 8); const hitMat = new THREE.MeshBasicMaterial({ color: 0xff0000, visible: false }); const hitMesh = new THREE.Mesh(hitGeo, hitMat); hitMesh.position.copy(pos); const visualGeo = new THREE.SphereGeometry(0.06, 8, 8); const visualMat = new THREE.MeshBasicMaterial({ color: 0xff3333, depthTest:true, transparent:false }); const visualMesh = new THREE.Mesh(visualGeo, visualMat); hitMesh.add(visualMesh); return hitMesh; }
            
            getFullEdgeLine(edgeData) {
				// La nueva findClosestEdge devuelve { points: [Vector3, Vector3] }
				if (edgeData && edgeData.points) {
					return edgeData.points;
				}
				return [];
			}
            
		findClosestEdge(raycaster) {
			if (!this.virtualMesh || !this.state.selectedObj) return null;
		
			// 1. PASO CR√çTICO: Calcular la barrera visual (Oclusi√≥n)
			// Lanzamos el rayo contra la malla s√≥lida para ver qu√© est√° al frente.
			const meshHits = raycaster.intersectObject(this.state.selectedObj);
			
			// Si no golpeamos el objeto visualmente, no deber√≠amos poder seleccionar bordes
			// (A menos que quieras seleccionar bordes en el aire, pero para robustez es mejor esto)
			if (meshHits.length === 0) return null;
		
			// Esta es la distancia m√°xima permitida. Cualquier cosa detr√°s de esto est√° oculta.
			// Le damos un peque√±o margen (+0.1 o +0.2) para que los bordes superficiales sean detectables.
			const visibleDistanceLimit = meshHits[0].distance + 0.2;
		
			let bestEdge = null;
			let minDiff = Infinity; // Diferencia entre el rayo y el borde
			
			// Umbral de precisi√≥n del mouse (qu√© tan cerca debo hacer clic)
			const threshold = 0.3; 
			const matrix = this.state.selectedObj.matrixWorld;
			
			// Variables temporales para evitar basura en memoria
			const ptOnRay = new THREE.Vector3();
			const ptOnSeg = new THREE.Vector3();
			const ray = raycaster.ray;
		
			Object.values(this.virtualMesh.faces).forEach(face => {
				const verts = face.verts;
				for (let i = 0; i < verts.length; i++) {
					const id1 = verts[i];
					const id2 = verts[(i + 1) % verts.length];
		
					// Evitar duplicados (procesar 1-2 y 2-1)
					if (id1 > id2) continue; 
					
					const v1 = this.virtualMesh.verts[id1];
					const v2 = this.virtualMesh.verts[id2];
					
					// Transformar a coordenadas MUNDIALES
					const p1World = new THREE.Vector3(v1.x, v1.y, v1.z).applyMatrix4(matrix);
					const p2World = new THREE.Vector3(v2.x, v2.y, v2.z).applyMatrix4(matrix);
		
					// Calcular distancia matem√°tica Rayo <-> Segmento
					const distSq = ray.distanceSqToSegment(p1World, p2World, ptOnRay, ptOnSeg);
		
					if (distSq < threshold) {
						// AQU√ç EST√Å LA L√ìGICA ROBUSTA:
						// Calculamos qu√© tan lejos est√° este borde de la c√°mara
						const distanceToCamera = ray.origin.distanceTo(ptOnSeg);
		
						// Si el borde est√° m√°s lejos que la pared visible del objeto, LO IGNORAMOS.
						if (distanceToCamera < visibleDistanceLimit) {
							// Es un borde visible, comprobamos si es el m√°s cercano al mouse
							if (distSq < minDiff) {
								minDiff = distSq;
								bestEdge = { 
									ids: [id1, id2], 
									points: [p1World, p2World] 
								};
							}
						}
					}
				}
			});
		
			return bestEdge;
		}	

        findClosestVisibleEdge(raycaster) {
            const mesh = this.state.selectedObj;
            if (!mesh) return null;
            const grid = this.getStructuredHandles(mesh);
            if (!grid) return null;

            const meshHits = raycaster.intersectObject(mesh);
            let maxHitDistance = Infinity;
            if (meshHits.length > 0) {
                maxHitDistance = meshHits[0].distance;
            }

            const segs = mesh.userData.segments;
            let bestEdge = null;
            let minVisualDistSq = Infinity;
            
            const THRESHOLD_SQ = 0.5 * 0.5; 

            const ray = raycaster.ray;
            const ptOnRay = new THREE.Vector3();
            const ptOnSeg = new THREE.Vector3();

            const check = (h1, h2) => {
                if (!h1 || !h2) return;

                const distSq = ray.distanceSqToSegment(h1.position, h2.position, ptOnRay, ptOnSeg);

                if (distSq < THRESHOLD_SQ) {
                    
                    const distanceToCamera = ptOnRay.distanceTo(ray.origin);

                    if (distanceToCamera < maxHitDistance + 0.1) {
                        
                        if (distSq < minVisualDistSq) {
                            minVisualDistSq = distSq;
                            bestEdge = [h1, h2];
                        }
                    }
                }
            };

            if (grid.length > 0) {
                // X Axis
                for(let i=0; i < segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k <= segs.z; k++) 
                    if(grid[i] && grid[i+1] && grid[i][j] && grid[i+1][j]) check(grid[i][j][k], grid[i+1][j][k]);
                // Y Axis
                for(let i=0; i <= segs.x; i++) for(let j=0; j < segs.y; j++) for(let k=0; k <= segs.z; k++) 
                    if(grid[i] && grid[i][j] && grid[i][j+1]) check(grid[i][j][k], grid[i][j+1][k]);
                // Z Axis
                for(let i=0; i <= segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k < segs.z; k++) 
                    if(grid[i] && grid[i][j] && grid[i][j][k] && grid[i][j][k+1]) check(grid[i][j][k], grid[i][j][k+1]);
            }

            return bestEdge;
        }
	
            drawLoopPreview(axis, index, ratio) { 
                const mesh = this.state.selectedObj; const grid = this.getStructuredHandles(mesh); const segs = mesh.userData.segments; const pts = []; 
                const lerpPos = (h1, h2) => h1.position.clone().lerp(h2.position.clone(), ratio); const addSegment = (pA, pB) => { pts.push(pA, pB); }; 
                if(axis === 'x') { for(let j=0; j<segs.y; j++) addSegment(lerpPos(grid[index][j][0], grid[index+1][j][0]), lerpPos(grid[index][j+1][0], grid[index+1][j+1][0])); for(let k=0; k<segs.z; k++) addSegment(lerpPos(grid[index][segs.y][k], grid[index+1][segs.y][k]), lerpPos(grid[index][segs.y][k+1], grid[index+1][segs.y][k+1])); for(let j=segs.y; j>0; j--) addSegment(lerpPos(grid[index][j][segs.z], grid[index+1][j][segs.z]), lerpPos(grid[index][j-1][segs.z], grid[index+1][j-1][segs.z])); for(let k=segs.z; k>0; k--) addSegment(lerpPos(grid[index][0][k], grid[index+1][0][k]), lerpPos(grid[index][0][k-1], grid[index+1][0][k-1])); } 
                else if(axis === 'y') { for(let i=0; i<segs.x; i++) addSegment(lerpPos(grid[i][index][0], grid[i][index+1][0]), lerpPos(grid[i+1][index][0], grid[i+1][index+1][0])); for(let k=0; k<segs.z; k++) addSegment(lerpPos(grid[segs.x][index][k], grid[segs.x][index+1][k]), lerpPos(grid[segs.x][index][k+1], grid[segs.x][index+1][k+1])); for(let i=segs.x; i>0; i--) addSegment(lerpPos(grid[i][index][segs.z], grid[i][index+1][segs.z]), lerpPos(grid[i-1][index][segs.z], grid[i-1][index+1][segs.z])); for(let k=segs.z; k>0; k--) addSegment(lerpPos(grid[0][index][k], grid[0][index+1][k]), lerpPos(grid[0][index][k-1], grid[0][index+1][k-1])); } 
                else if(axis === 'z') { for(let i=0; i<segs.x; i++) addSegment(lerpPos(grid[i][0][index], grid[i][0][index+1]), lerpPos(grid[i+1][0][index], grid[i+1][0][index+1])); for(let j=0; j<segs.y; j++) addSegment(lerpPos(grid[segs.x][j][index], grid[segs.x][j][index+1]), lerpPos(grid[segs.x][j+1][index], grid[segs.x][j+1][index+1])); for(let i=segs.x; i>0; i--) addSegment(lerpPos(grid[i][segs.y][index], grid[i][segs.y][index+1]), lerpPos(grid[i-1][segs.y][index], grid[i-1][segs.y][index+1])); for(let j=segs.y; j>0; j--) addSegment(lerpPos(grid[0][j][index], grid[0][j][index+1]), lerpPos(grid[0][j-1][index], grid[0][j-1][index+1])); } 
                this.cutPreviewHelper.geometry.setFromPoints(pts); 
            }
            initUI() { 
                const btnObj = document.getElementById('btn-mode-obj'); const btnEdit = document.getElementById('btn-mode-edit'); 
                btnObj.onclick = () => { if(this.state.mode === 'edit') { btnObj.classList.add('active'); btnEdit.classList.remove('active'); this.exitEditMode(); } }; 
                btnEdit.onclick = () => { if(this.state.mode === 'object' && this.state.selectedObj) { btnObj.classList.remove('active'); btnEdit.classList.add('active'); this.enterEditMode(); } }; 
                
				const setSubMode = (mode, id) => {
					document.getElementById(id).onclick = () => {
						this.state.selectMode = mode;
						document.querySelectorAll('.sub-opt').forEach(b => b.classList.remove('active'));
						document.getElementById(id).classList.add('active');
						this.gizmo.detach();
						this.clearSelectionVisuals();
						document.getElementById('status').innerText = `Modo ${mode === 'vertex' ? 'Puntos' : mode === 'edge' ? 'Bordes' : 'Caras'}`;
					}
				};
				setSubMode('vertex', 'sel-vertex');
				setSubMode('edge', 'sel-edge');
				setSubMode('face', 'sel-face');
				this.updateGeometryFromHandles();
				
                document.getElementById('btn-toggle-wire').onclick = () => this.toggleWireframeMode();
                document.getElementById('btn-add').onclick = () => this.addCube(); 
                document.getElementById('btn-delete').onclick = () => { if(this.state.selectedObj && this.state.mode === 'object') { this.scene.remove(this.state.selectedObj); this.objects = this.objects.filter(o => o !== this.state.selectedObj); this.selectObject(null); this.gizmo.detach(); } }; 
                document.getElementById('tool-select').onclick = () => { 
                    this.state.editTool = 'select'; this.updateToolUI('tool-select'); 
                    document.getElementById('status').innerText = "Seleccionar Puntos"; 
                    this.resetKnifeTool(); 
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); 
                    this.state.multiSelection = []; 
                    this.connectionLine.visible = false;
                    document.getElementById('action-container').classList.add('hidden');
                    this.orbit.enabled = true; this.gizmo.attach(this.handles[0]); this.gizmo.detach();
                }; 
                document.getElementById('tool-cut').onclick = () => { 
                    this.state.editTool = 'cut'; this.updateToolUI('tool-cut'); 
                    document.getElementById('status').innerText = "Cuchillo: Selecciona un borde"; 
                    this.gizmo.detach(); this.orbit.enabled = false; 
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); this.state.multiSelection = []; 
                    this.connectionLine.visible = false; document.getElementById('action-container').classList.add('hidden');
                };
                document.getElementById('tool-connect').onclick = () => {
                    this.state.editTool = 'connect'; this.updateToolUI('tool-connect');
                    document.getElementById('status').innerText = "Toca 2 v√©rtices";
                    this.gizmo.detach(); this.orbit.enabled = true;
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); this.state.multiSelection = []; 
                    this.connectionLine.visible = false; document.getElementById('action-container').classList.add('hidden');
                };
				document.getElementById('tool-extrude').addEventListener('click', () => {
					if(this.state.selectedFaceId !== undefined && this.state.selectedFaceId !== null) {
						
						// Ejecutar extrusi√≥n l√≥gica
						this.virtualMesh.extrudeFace(this.state.selectedFaceId, 1.0); 
						
						// Limpiar visuales viejos
						this.clearHandles(); 
						this.state.selectedObj.updateMatrixWorld(); // Importante
				
						// REGENERAR HANDLES (CON CORRECCI√ìN DE MATRIZ)
						Object.values(this.virtualMesh.verts).forEach(v => {
							const localPos = new THREE.Vector3(v.x, v.y, v.z);
							
							// CORRECCI√ìN AQU√ç TAMBI√âN:
							const worldPos = localPos.applyMatrix4(this.state.selectedObj.matrixWorld);
							
							const handle = this.createHandleMesh(worldPos);
							handle.userData.virtId = v.id;
							this.handles.push(handle);
							this.scene.add(handle);
							v.handle = handle;
						});
						
						this.updateGeometryFromHandles();
						this.clearSelectionVisuals();
					}
				});
                document.getElementById('btn-connect-action').onclick = () => this.performConnection();
                document.getElementById('btn-export').onclick = () => this.exportGLB(); 
                const setMode = (mode, id) => { document.getElementById(id).onclick = () => { this.gizmo.setMode(mode); document.querySelectorAll('#transform-tools button').forEach(b => b.classList.remove('active')); document.getElementById(id).classList.add('active'); }}; setMode('translate', 'mode-translate'); setMode('rotate', 'mode-rotate'); setMode('scale', 'mode-scale'); 
            }
            updateToolUI(activeId) { document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active')); document.getElementById(activeId).classList.add('active'); }
            addCube() { 
                const segs = { x:1, y:1, z:1 }; 
                const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5, segs.x, segs.y, segs.z); 
                const mat = new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.9, metalness: 0.1, flatShading: false, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 }); 
                const mesh = new THREE.Mesh(geo, mat); mesh.userData.segments = segs; mesh.position.y = 0.75; 
                this.scene.add(mesh); this.objects.push(mesh); this.selectObject(mesh); 
            }
			
			            // ============================================
            // FIX MODO 3: SELECCI√ìN DE CARAS MATEM√ÅTICA
            // ============================================
			findClosestFace(raycaster) {
				if (!this.state.selectedObj || !this.virtualMesh) return null;
			
				// 1. Raycast est√°ndar contra la malla visual
				const intersects = raycaster.intersectObject(this.state.selectedObj);
				if (intersects.length === 0) return null;
			
				const hit = intersects[0];
				const faceIndex = hit.faceIndex; // √çndice del tri√°ngulo en Three.js
			
				// 2. Mapear tri√°ngulo -> Cara Virtual
				// Necesitamos saber qu√© "Cara Virtual" gener√≥ este tri√°ngulo.
				// La forma m√°s robusta es buscar qu√© cara contiene los v√©rtices golpeados.
				
				// Obtenemos los √≠ndices de v√©rtices del tri√°ngulo golpeado
				const geo = this.state.selectedObj.geometry;
				const a = geo.index.getX(faceIndex * 3);
				const b = geo.index.getY(faceIndex * 3);
				const c = geo.index.getZ(faceIndex * 3);
			
				// Convertir posiciones del tri√°ngulo a string para comparar (o usar proximidad)
				// PERO: Si implementaste mi `toBufferGeometry`, los v√©rtices se regeneran en orden.
				// ESTRATEGIA SEGURA: Buscar geom√©tricamente qu√© cara virtual est√° m√°s cerca del punto de impacto.
				
				let bestFaceId = -1;
				let minCenterDist = Infinity;
				const localPoint = this.state.selectedObj.worldToLocal(hit.point.clone());
			
				Object.values(this.virtualMesh.faces).forEach(face => {
					// Calcular centroide de la cara virtual
					let cx=0, cy=0, cz=0;
					face.verts.forEach(vid => {
						const v = this.virtualMesh.verts[vid];
						cx += v.x; cy += v.y; cz += v.z;
					});
					cx /= face.verts.length;
					cy /= face.verts.length;
					cz /= face.verts.length;
			
					const dist = localPoint.distanceTo(new THREE.Vector3(cx, cy, cz));
					if(dist < minCenterDist) {
						minCenterDist = dist;
						bestFaceId = face.id;
					}
				});
			
				// Retornamos los handles correspondientes a esta cara para que se iluminen
				if (bestFaceId !== -1) {
					const face = this.virtualMesh.faces[bestFaceId];
					// Buscar los handles visuales asociados a estos IDs
					const handles = face.verts.map(vid => this.virtualMesh.verts[vid].handle).filter(h => h);
					
					// Guardamos el ID de la cara seleccionada en el estado global para usarlo al extruir
					this.state.selectedFaceId = bestFaceId; 
					
					return handles;
				}
				return null;
			}

			
			setSelection(handles, label) {
				this.state.selectedGroup = handles;
				document.getElementById('status').innerText = label;
			
				if (handles.length === 1) {
					this.gizmo.attach(handles[0]); 
				} else {
					const center = new THREE.Vector3();
					handles.forEach(h => center.add(h.position));
					center.divideScalar(handles.length);
					
					this.dummy.position.copy(center);
					this.dummy.rotation.set(0,0,0);
					this.dummy.scale.set(1,1,1);
					this.dummy.updateMatrixWorld();
					
					this.gizmo.attach(this.dummy); 
				}
			}
			
			clearSelectionVisuals() {
				if(this.edgeHighlightHelper) this.edgeHighlightHelper.visible = false;
				if(this.faceHighlightHelper) this.faceHighlightHelper.visible = false;
				this.state.selectedGroup = [];
			}
			
            exportGLB() { this.exitEditMode(); const exporter = new GLTFExporter(); exporter.parse(this.objects, (gltf) => { const blob = new Blob([gltf], { type: 'application/octet-stream' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = 'modelo_smooth_cut.glb'; link.click(); }, (err) => console.error(err), { binary: true }); }
            render() { this.orbit.update(); this.renderer.render(this.scene, this.camera); }
        }
        new App();
    </script>
  </body>
</html>
