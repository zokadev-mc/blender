


                
                this.state.userEdges = []; 

                this.gizmo.detach();
				document.getElementById('sub-mode-bar').classList.add('hidden');
                document.getElementById('edit-tools-bar').classList.add('hidden');
                document.getElementById('transform-tools').classList.remove('hidden');
                if(this.state.selectedObj) this.gizmo.attach(this.state.selectedObj);
                document.getElementById('status').innerText = "Modo Objeto";
            }

            clearHandles() { this.handles.forEach(h => { if(h.parent) h.parent.remove(h); }); this.handles = []; this.vertexMap = []; }
            selectObject(mesh) { this.state.selectedObj = mesh; if(mesh) { mesh.material.emissive.setHex(0x333333); if(this.state.mode === 'object') this.gizmo.attach(mesh); } else { this.gizmo.detach(); } }
            
			// ============================================
			// FUNCIÓN TAP BLINDADA (SOLUCIÓN AL BUG)
			// ============================================
			handleTap(x, y) { 
				const rect = this.renderer.domElement.getBoundingClientRect(); 
				const mouse = new THREE.Vector2(((x-rect.left)/rect.width)*2-1, -((y-rect.top)/rect.height)*2+1); 
				this.raycaster.setFromCamera(mouse, this.camera); 
				const statusLabel = document.getElementById('status'); 
			
				// 1. MODO OBJETO (Sin cambios)
				if (this.state.mode === 'object') { 
					const hits = this.raycaster.intersectObjects(this.objects); 
					if (hits.length > 0) { this.selectObject(hits[0].object); statusLabel.innerText = "Objeto Seleccionado"; } 
					else { this.selectObject(null); statusLabel.innerText = "Modo Objeto"; } 
					return; 
				} 
			
				// 2. MODO EDICIÓN
				this.clearSelectionVisuals();
				
				// *** PASO CRÍTICO: Desactivar Gizmo POR DEFECTO ***
				// Esto asegura que si tocas el aire o la cara del cubo sin tocar un componente válido,
				// el gizmo se apaga y NO selecciona el objeto principal.
				this.gizmo.detach();
			
				if (this.state.editTool === 'select') {
					
					// SUB-MODO: VÉRTICES
					if (this.state.selectMode === 'vertex') {
						const targets = [...this.handles];
						// Nota: NO agregamos selectedObj a targets para evitar falsos positivos
						
						// Intersectamos SOLO los handles visibles
						const hits = this.raycaster.intersectObjects(targets, true);
						
						// Filtro estricto: ¿Es realmente un handle?
						const validHit = hits.find(h => {
							return this.handles.includes(h.object) || (h.object.parent && this.handles.includes(h.object.parent));
						});

						if (validHit) {
							const handle = this.handles.includes(validHit.object) ? validHit.object : validHit.object.parent;
							this.setSelection([handle], "Vértice Seleccionado");
						} 
						// Si no hay hit válido, el gizmo ya está detach() por defecto arriba.
					} 
					
					// SUB-MODO: BORDES
					else if (this.state.selectMode === 'edge') {
						const closestEdge = this.findClosestVisibleEdge(this.raycaster);
						if (closestEdge) {
							const [h1, h2] = closestEdge;
							this.setSelection([h1, h2], "Borde Seleccionado");
							this.edgeHighlightHelper.geometry.setFromPoints([h1.position, h2.position]);
							this.edgeHighlightHelper.visible = true;
						}
					}
			
					// SUB-MODO: CARAS
					else if (this.state.selectMode === 'face') {
						const face = this.findClosestFace(this.raycaster);
						if (face) {
							this.setSelection(face, "Cara Seleccionada");
							const p = face.map(h => h.position);
							const pos = [p[0].x, p[0].y, p[0].z, p[1].x, p[1].y, p[1].z, p[3].x, p[3].y, p[3].z,  p[1].x, p[1].y, p[1].z, p[2].x, p[2].y, p[2].z, p[3].x, p[3].y, p[3].z];
							this.faceHighlightHelper.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
							this.faceHighlightHelper.visible = true;
						}
					}
					return;
				}
			}	
	
					updateGeometryFromHandles() { 
					const mesh = this.state.selectedObj; 
					if (!mesh || !mesh.geometry) return; 
					
					const posAttr = mesh.geometry.attributes.position; 
					
					// 1. Actualizar la forma del cubo (física)
					for(let i=0; i < this.vertexMap.length; i++) { 
						const handleIdx = this.vertexMap[i]; 
						if(handleIdx !== undefined && handleIdx !== -1 && handleIdx < this.handles.length) { 
							const handle = this.handles[handleIdx]; 
							const worldPos = handle.position.clone(); 
							mesh.worldToLocal(worldPos); 
							posAttr.setXYZ(i, worldPos.x, worldPos.y, worldPos.z); 
						} 
					} 
					posAttr.needsUpdate = true; 
					mesh.geometry.computeVertexNormals(); 
				
					// 2. Actualizar el Wireframe Rojo (la malla general)
					if (this.state.mode === 'edit') {
						this.setupDirectWireframe(mesh);
					}
					
					// 3. Actualizar visualmente la selección (Verde/Amarillo) en tiempo real
					
					// CASO BORDES: Si estamos moviendo un borde, redibujar la línea
					if(this.state.selectMode === 'edge' && this.state.selectedGroup.length === 2) {
						const pts = this.state.selectedGroup.map(h => h.position);
						this.edgeHighlightHelper.geometry.setFromPoints(pts);
					}
				
					// CASO CARAS: Si estamos moviendo una cara, redibujar el cuadrado rojo
					if(this.state.selectMode === 'face' && this.state.selectedGroup.length === 4) {
						const h = this.state.selectedGroup;
						const pos = [
							h[0].position, h[1].position, h[3].position, 
							h[1].position, h[2].position, h[3].position  
						].flatMap(p => [p.x, p.y, p.z]);
				
						this.faceHighlightHelper.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
					}
				}         
		 
            createHandleMesh(pos) { const hitGeo = new THREE.SphereGeometry(0.15, 8, 8); const hitMat = new THREE.MeshBasicMaterial({ color: 0xff0000, visible: false }); const hitMesh = new THREE.Mesh(hitGeo, hitMat); hitMesh.position.copy(pos); const visualGeo = new THREE.SphereGeometry(0.06, 8, 8); const visualMat = new THREE.MeshBasicMaterial({ color: 0xff3333, depthTest:true, transparent:false }); const visualMesh = new THREE.Mesh(visualGeo, visualMat); hitMesh.add(visualMesh); return hitMesh; }
            
            getFullEdgeLine(edge) {
                if(!this.state.selectedObj || !edge) return [];
                
                const grid = this.getStructuredHandles(this.state.selectedObj);
                if (!grid || !grid.length) return [];
                
                const nx = grid.length;
                const ny = grid[0]?.length || 0;
                const nz = grid[0]?.[0]?.length || 0;

                const { axis, x, y, z } = edge;
                const points = [];

                const getPos = (i, j, k) => grid[i]?.[j]?.[k]?.position;

                if (axis === 'x' || axis === 'z') {
                    const j = y; 
                    
                    for(let i=0; i < nx - 1; i++) {
                        const p1 = getPos(i, j, nz-1);
                        const p2 = getPos(i+1, j, nz-1);
                        if(p1 && p2) points.push(p1, p2);

                        const p3 = getPos(i, j, 0);
                        const p4 = getPos(i+1, j, 0);
                        if(p3 && p4) points.push(p3, p4);
                    }

                    for(let k=0; k < nz - 1; k++) {
                        const p1 = getPos(0, j, k);
                        const p2 = getPos(0, j, k+1);
                        if(p1 && p2) points.push(p1, p2);

                        const p3 = getPos(nx-1, j, k);
                        const p4 = getPos(nx-1, j, k+1);
                        if(p3 && p4) points.push(p3, p4);
                    }
                }
                
                else if (axis === 'y') {
                    if (z === 0 || z === nz - 1) {
                        const i = x; 
                        
                        for(let j=0; j < ny - 1; j++) {
                            const p1 = getPos(i, j, 0);     
                            const p2 = getPos(i, j+1, 0);
                            if(p1 && p2) points.push(p1, p2);

                            const p3 = getPos(i, j, nz-1);  
                            const p4 = getPos(i, j+1, nz-1);
                            if(p3 && p4) points.push(p3, p4);
                        }
                        
                        for(let k=0; k < nz - 1; k++) {
                            const p1 = getPos(i, 0, k);     
                            const p2 = getPos(i, 0, k+1);
                            if(p1 && p2) points.push(p1, p2);

                            const p3 = getPos(i, ny-1, k);  
                            const p4 = getPos(i, ny-1, k+1);
                            if(p3 && p4) points.push(p3, p4);
                        }
                    }
                    else {
                        const k = z; 
                        
                        for(let j=0; j < ny - 1; j++) {
                            const p1 = getPos(0, j, k);     
                            const p2 = getPos(0, j+1, k);
                            if(p1 && p2) points.push(p1, p2);

                            const p3 = getPos(nx-1, j, k);  
                            const p4 = getPos(nx-1, j+1, k);
                            if(p3 && p4) points.push(p3, p4);
                        }

                        for(let i=0; i < nx - 1; i++) {
                            const p1 = getPos(i, 0, k);     
                            const p2 = getPos(i+1, 0, k);
                            if(p1 && p2) points.push(p1, p2);

                            const p3 = getPos(i, ny-1, k);  
                            const p4 = getPos(i+1, ny-1, k);
                            if(p3 && p4) points.push(p3, p4);
                        }
                    }
                }
                
                return points; 
            }
            
		findClosestEdge(raycaster) { 
			const mesh = this.state.selectedObj; 
			if(!mesh) return null;
		
			const grid = this.getStructuredHandles(mesh); 
			if(!grid) return null; 
		
			const segs = mesh.userData.segments; 
			let bestEdge = null, minDst = Infinity; 
			
			const ray = raycaster.ray; 
			const ptOnRay = new THREE.Vector3();
			const ptOnSeg = new THREE.Vector3(); 
		
			const checkEdge = (h1, h2, axis, x, y, z) => { 
				if (!h1 || !h2) return;
		
				const dstSq = ray.distanceSqToSegment(h1.position, h2.position, ptOnRay, ptOnSeg); 
				
				if(dstSq < minDst) { 
					minDst = dstSq; 
					bestEdge = { h1, h2, axis, x, y, z }; 
				} 
			}; 
		
			if (grid.length > 0) {
				for(let i=0; i < segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k <= segs.z; k++) if(grid[i] && grid[i+1] && grid[i][j] && grid[i+1][j]) checkEdge(grid[i][j][k], grid[i+1][j][k], 'x', i, j, k); 
				for(let i=0; i <= segs.x; i++) for(let j=0; j < segs.y; j++) for(let k=0; k <= segs.z; k++) if(grid[i] && grid[i][j] && grid[i][j+1]) checkEdge(grid[i][j][k], grid[i][j+1][k], 'y', i, j, k); 
				for(let i=0; i <= segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k < segs.z; k++) if(grid[i] && grid[i][j] && grid[i][j][k] && grid[i][j][k+1]) checkEdge(grid[i][j][k], grid[i][j][k+1], 'z', i, j, k); 
			}
		
			return (Math.sqrt(minDst) < 0.5) ? bestEdge : null; 
		}	

        findClosestVisibleEdge(raycaster) {
            const mesh = this.state.selectedObj;
            if (!mesh) return null;
            const grid = this.getStructuredHandles(mesh);
            if (!grid) return null;

            const meshHits = raycaster.intersectObject(mesh);
            let maxHitDistance = Infinity;
            if (meshHits.length > 0) {
                maxHitDistance = meshHits[0].distance;
            }

            const segs = mesh.userData.segments;
            let bestEdge = null;
            let minVisualDistSq = Infinity;
            
            const THRESHOLD_SQ = 0.5 * 0.5; 

            const ray = raycaster.ray;
            const ptOnRay = new THREE.Vector3();
            const ptOnSeg = new THREE.Vector3();

            const check = (h1, h2) => {
                if (!h1 || !h2) return;

                const distSq = ray.distanceSqToSegment(h1.position, h2.position, ptOnRay, ptOnSeg);

                if (distSq < THRESHOLD_SQ) {
                    
                    const distanceToCamera = ptOnRay.distanceTo(ray.origin);

                    if (distanceToCamera < maxHitDistance + 0.1) {
                        
                        if (distSq < minVisualDistSq) {
                            minVisualDistSq = distSq;
                            bestEdge = [h1, h2];
                        }
                    }
                }
            };

            if (grid.length > 0) {
                // X Axis
                for(let i=0; i < segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k <= segs.z; k++) 
                    if(grid[i] && grid[i+1] && grid[i][j] && grid[i+1][j]) check(grid[i][j][k], grid[i+1][j][k]);
                // Y Axis
                for(let i=0; i <= segs.x; i++) for(let j=0; j < segs.y; j++) for(let k=0; k <= segs.z; k++) 
                    if(grid[i] && grid[i][j] && grid[i][j+1]) check(grid[i][j][k], grid[i][j+1][k]);
                // Z Axis
                for(let i=0; i <= segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k < segs.z; k++) 
                    if(grid[i] && grid[i][j] && grid[i][j][k] && grid[i][j][k+1]) check(grid[i][j][k], grid[i][j][k+1]);
            }

            return bestEdge;
        }
	
            drawLoopPreview(axis, index, ratio) { 
                const mesh = this.state.selectedObj; const grid = this.getStructuredHandles(mesh); const segs = mesh.userData.segments; const pts = []; 
                const lerpPos = (h1, h2) => h1.position.clone().lerp(h2.position.clone(), ratio); const addSegment = (pA, pB) => { pts.push(pA, pB); }; 
                if(axis === 'x') { for(let j=0; j<segs.y; j++) addSegment(lerpPos(grid[index][j][0], grid[index+1][j][0]), lerpPos(grid[index][j+1][0], grid[index+1][j+1][0])); for(let k=0; k<segs.z; k++) addSegment(lerpPos(grid[index][segs.y][k], grid[index+1][segs.y][k]), lerpPos(grid[index][segs.y][k+1], grid[index+1][segs.y][k+1])); for(let j=segs.y; j>0; j--) addSegment(lerpPos(grid[index][j][segs.z], grid[index+1][j][segs.z]), lerpPos(grid[index][j-1][segs.z], grid[index+1][j-1][segs.z])); for(let k=segs.z; k>0; k--) addSegment(lerpPos(grid[index][0][k], grid[index+1][0][k]), lerpPos(grid[index][0][k-1], grid[index+1][0][k-1])); } 
                else if(axis === 'y') { for(let i=0; i<segs.x; i++) addSegment(lerpPos(grid[i][index][0], grid[i][index+1][0]), lerpPos(grid[i+1][index][0], grid[i+1][index+1][0])); for(let k=0; k<segs.z; k++) addSegment(lerpPos(grid[segs.x][index][k], grid[segs.x][index+1][k]), lerpPos(grid[segs.x][index][k+1], grid[segs.x][index+1][k+1])); for(let i=segs.x; i>0; i--) addSegment(lerpPos(grid[i][index][segs.z], grid[i][index+1][segs.z]), lerpPos(grid[i-1][index][segs.z], grid[i-1][index+1][segs.z])); for(let k=segs.z; k>0; k--) addSegment(lerpPos(grid[0][index][k], grid[0][index+1][k]), lerpPos(grid[0][index][k-1], grid[0][index+1][k-1])); } 
                else if(axis === 'z') { for(let i=0; i<segs.x; i++) addSegment(lerpPos(grid[i][0][index], grid[i][0][index+1]), lerpPos(grid[i+1][0][index], grid[i+1][0][index+1])); for(let j=0; j<segs.y; j++) addSegment(lerpPos(grid[segs.x][j][index], grid[segs.x][j][index+1]), lerpPos(grid[segs.x][j+1][index], grid[segs.x][j+1][index+1])); for(let i=segs.x; i>0; i--) addSegment(lerpPos(grid[i][segs.y][index], grid[i][segs.y][index+1]), lerpPos(grid[i-1][segs.y][index], grid[i-1][segs.y][index+1])); for(let j=segs.y; j>0; j--) addSegment(lerpPos(grid[0][j][index], grid[0][j][index+1]), lerpPos(grid[0][j-1][index], grid[0][j-1][index+1])); } 
                this.cutPreviewHelper.geometry.setFromPoints(pts); 
            }
            initUI() { 
                const btnObj = document.getElementById('btn-mode-obj'); const btnEdit = document.getElementById('btn-mode-edit'); 
                btnObj.onclick = () => { if(this.state.mode === 'edit') { btnObj.classList.add('active'); btnEdit.classList.remove('active'); this.exitEditMode(); } }; 
                btnEdit.onclick = () => { if(this.state.mode === 'object' && this.state.selectedObj) { btnObj.classList.remove('active'); btnEdit.classList.add('active'); this.enterEditMode(); } }; 
                
				const setSubMode = (mode, id) => {
					document.getElementById(id).onclick = () => {
						this.state.selectMode = mode;
						document.querySelectorAll('.sub-opt').forEach(b => b.classList.remove('active'));
						document.getElementById(id).classList.add('active');
						this.gizmo.detach();
						this.clearSelectionVisuals();
						document.getElementById('status').innerText = `Modo ${mode === 'vertex' ? 'Puntos' : mode === 'edge' ? 'Bordes' : 'Caras'}`;
					}
				};
				setSubMode('vertex', 'sel-vertex');
				setSubMode('edge', 'sel-edge');
				setSubMode('face', 'sel-face');
				this.updateGeometryFromHandles();
				
                document.getElementById('btn-toggle-wire').onclick = () => this.toggleWireframeMode();
                document.getElementById('btn-add').onclick = () => this.addCube(); 
                document.getElementById('btn-delete').onclick = () => { if(this.state.selectedObj && this.state.mode === 'object') { this.scene.remove(this.state.selectedObj); this.objects = this.objects.filter(o => o !== this.state.selectedObj); this.selectObject(null); this.gizmo.detach(); } }; 
                document.getElementById('tool-select').onclick = () => { 
                    this.state.editTool = 'select'; this.updateToolUI('tool-select'); 
                    document.getElementById('status').innerText = "Seleccionar Puntos"; 
                    this.resetKnifeTool(); 
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); 
                    this.state.multiSelection = []; 
                    this.connectionLine.visible = false;
                    document.getElementById('action-container').classList.add('hidden');
                    this.orbit.enabled = true; this.gizmo.attach(this.handles[0]); this.gizmo.detach();
                }; 
                document.getElementById('tool-cut').onclick = () => { 
                    this.state.editTool = 'cut'; this.updateToolUI('tool-cut'); 
                    document.getElementById('status').innerText = "Cuchillo: Selecciona un borde"; 
                    this.gizmo.detach(); this.orbit.enabled = false; 
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); this.state.multiSelection = []; 
                    this.connectionLine.visible = false; document.getElementById('action-container').classList.add('hidden');
                };
                document.getElementById('tool-connect').onclick = () => {
                    this.state.editTool = 'connect'; this.updateToolUI('tool-connect');
                    document.getElementById('status').innerText = "Toca 2 vértices";
                    this.gizmo.detach(); this.orbit.enabled = true;
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); this.state.multiSelection = []; 
                    this.connectionLine.visible = false; document.getElementById('action-container').classList.add('hidden');
                };
                document.getElementById('btn-connect-action').onclick = () => this.performConnection();
                document.getElementById('btn-export').onclick = () => this.exportGLB(); 
                const setMode = (mode, id) => { document.getElementById(id).onclick = () => { this.gizmo.setMode(mode); document.querySelectorAll('#transform-tools button').forEach(b => b.classList.remove('active')); document.getElementById(id).classList.add('active'); }}; setMode('translate', 'mode-translate'); setMode('rotate', 'mode-rotate'); setMode('scale', 'mode-scale'); 
            }
            updateToolUI(activeId) { document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active')); document.getElementById(activeId).classList.add('active'); }
            addCube() { 
                const segs = { x:1, y:1, z:1 }; 
                const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5, segs.x, segs.y, segs.z); 
                const mat = new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.9, metalness: 0.1, flatShading: false, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 }); 
                const mesh = new THREE.Mesh(geo, mat); mesh.userData.segments = segs; mesh.position.y = 0.75; 
                this.scene.add(mesh); this.objects.push(mesh); this.selectObject(mesh); 
            }
			
			            // ============================================
            // FIX MODO 3: SELECCIÓN DE CARAS MATEMÁTICA
            // ============================================
            findClosestFace(raycaster) {
                const mesh = this.state.selectedObj; if(!mesh) return null;
                const grid = this.getStructuredHandles(mesh); if(!grid) return null;
                const segs = mesh.userData.segments;

                // Variables para matemáticas (reutilizables para rendimiento)
                const ray = raycaster.ray;
                const pA = new THREE.Vector3(); const pB = new THREE.Vector3();
                const pC = new THREE.Vector3(); const pD = new THREE.Vector3();
                const hitPoint = new THREE.Vector3();

                let bestFace = null;
                let minDst = Infinity;

                // Función que verifica si el rayo cruza el Quad formado por 4 handles
                const checkQuad = (h1, h2, h3, h4) => {
                    if (!h1 || !h2 || !h3 || !h4) return;

                    pA.copy(h1.position); pB.copy(h2.position);
                    pC.copy(h3.position); pD.copy(h4.position);

                    // Un Quad son 2 Triángulos. Probamos intersección matemática directa.
                    // Triángulo 1: A-B-D
                    let intersect = ray.intersectTriangle(pA, pB, pD, false, hitPoint);
                    if (!intersect) {
                        // Triángulo 2: B-C-D
                        intersect = ray.intersectTriangle(pB, pC, pD, false, hitPoint);
                    }

                    if (intersect) {
                        // Si golpea, calculamos la distancia a la cámara
                        const dist = ray.origin.distanceTo(hitPoint);
                        // Nos quedamos solo con la cara más cercana (Oclusión automática)
                        if (dist < minDst) {
                            minDst = dist;
                            bestFace = [h1, h2, h3, h4];
                        }
                    }
                };

                // Barrido de Caras en los 3 Ejes (X, Y, Z)
                // 1. Plano YZ (Caras laterales X)
                for(let i=0; i <= segs.x; i++) {
                    for(let j=0; j < segs.y; j++) {
                        for(let k=0; k < segs.z; k++) {
                            if(grid[i] && grid[i][j] && grid[i][j][k]) {
                                checkQuad(grid[i][j][k], grid[i][j+1][k], grid[i][j+1][k+1], grid[i][j][k+1]);
                            }
                        }
                    }
                }

                // 2. Plano XZ (Caras laterales Y - Arriba/Abajo)
                for(let j=0; j <= segs.y; j++) {
                    for(let i=0; i < segs.x; i++) {
                        for(let k=0; k < segs.z; k++) {
                            if(grid[i] && grid[i][j] && grid[i][j][k]) {
                                checkQuad(grid[i][j][k], grid[i+1][j][k], grid[i+1][j][k+1], grid[i][j][k+1]);
                            }
                        }
                    }
                }

                // 3. Plano XY (Caras laterales Z - Frente/Atrás)
                for(let k=0; k <= segs.z; k++) {
                    for(let i=0; i < segs.x; i++) {
                        for(let j=0; j < segs.y; j++) {
                            if(grid[i] && grid[i][j] && grid[i][j][k]) {
                                checkQuad(grid[i][j][k], grid[i+1][j][k], grid[i+1][j+1][k], grid[i][j+1][k]);
                            }
                        }
                    }
                }

                return bestFace;
            }

			
			setSelection(handles, label) {
				this.state.selectedGroup = handles;
				document.getElementById('status').innerText = label;
			
				if (handles.length === 1) {
					this.gizmo.attach(handles[0]); 
				} else {
					const center = new THREE.Vector3();
					handles.forEach(h => center.add(h.position));
					center.divideScalar(handles.length);
					
					this.dummy.position.copy(center);
					this.dummy.rotation.set(0,0,0);
					this.dummy.scale.set(1,1,1);
					this.dummy.updateMatrixWorld();
					
					this.gizmo.attach(this.dummy); 
				}
			}
			
			clearSelectionVisuals() {
				if(this.edgeHighlightHelper) this.edgeHighlightHelper.visible = false;
				if(this.faceHighlightHelper) this.faceHighlightHelper.visible = false;
				this.state.selectedGroup = [];
			}
			
            exportGLB() { this.exitEditMode(); const exporter = new GLTFExporter(); exporter.parse(this.objects, (gltf) => { const blob = new Blob([gltf], { type: 'application/octet-stream' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = 'modelo_smooth_cut.glb'; link.click(); }, (err) => console.error(err), { binary: true }); }
            render() { this.orbit.update(); this.renderer.render(this.scene, this.camera); }
        }
        new App();
    </script>
  </body>
</html>
