


						handle.userData.virtId = v.id; 
						this.handles.push(handle);
						this.scene.add(handle);
						v.handle = handle; 
					});
								
					this.setupDirectWireframe(mesh);
					// Render extra para asegurar que se vean
					if(this.renderer && this.scene && this.camera) {
						this.renderer.render(this.scene, this.camera);
					}
				});

				document.getElementById('status').innerText = "Modo Edición: Activo";
				
				// UI
				document.getElementById('sub-mode-bar').classList.remove('hidden');
				document.getElementById('edit-tools-bar').classList.remove('hidden');
				document.getElementById('transform-tools').classList.add('hidden');
			}

            cacheGridIndices(mesh) {
                const segs = mesh.userData.segments;
                const nx = segs.x + 1;
                const ny = segs.y + 1;
                const nz = segs.z + 1;

                mesh.geometry.computeBoundingBox();
                const min = mesh.geometry.boundingBox.min;
                const max = mesh.geometry.boundingBox.max;
                const size = new THREE.Vector3().subVectors(max, min);

                if(size.x === 0) size.x = 1;
                if(size.y === 0) size.y = 1;
                if(size.z === 0) size.z = 1;

                if(!mesh.userData.gridInfo) mesh.userData.gridInfo = [];

                this.handles.forEach((h, hIdx) => {
                    const localPos = h.position.clone();
                    mesh.worldToLocal(localPos);

                    const percentX = (localPos.x - min.x) / size.x;
                    const percentY = (localPos.y - min.y) / size.y;
                    const percentZ = (localPos.z - min.z) / size.z;

                    const ix = Math.max(0, Math.min(nx - 1, Math.round(percentX * segs.x)));
                    const iy = Math.max(0, Math.min(ny - 1, Math.round(percentY * segs.y)));
                    const iz = Math.max(0, Math.min(nz - 1, Math.round(percentZ * segs.z)));

                    const vIdx = this.vertexMap.indexOf(hIdx);
                    if (vIdx !== -1) {
                         mesh.userData.gridInfo[vIdx] = { x: ix, y: iy, z: iz };
                    }
                });
            }
			
			generateSpatialGrid(mesh) {
                const segs = mesh.userData.segments;
                const nx = segs.x + 1;
                const ny = segs.y + 1;
                const nz = segs.z + 1;

                const items = this.handles.map(h => {
                    const localPos = h.position.clone();
                    mesh.worldToLocal(localPos);
                    return { h, x: localPos.x, y: localPos.y, z: localPos.z };
                });

                const EPSILON = 0.001; 

                const gapSort = (arr, prop) => {
                    arr.sort((a,b) => a[prop] - b[prop]); 
                    const buckets = [];
                    if (arr.length === 0) return buckets;
                    let currentBucket = [arr[0]];
                    buckets.push(currentBucket);
                    for (let i = 1; i < arr.length; i++) {
                        if (Math.abs(arr[i][prop] - arr[i-1][prop]) > EPSILON) {
                            currentBucket = [arr[i]];
                            buckets.push(currentBucket);
                        } else {
                            currentBucket.push(arr[i]);
                        }
                    }
                    return buckets;
                };

                const grid = [];
                const xBuckets = gapSort(items, 'x');
                
                if(xBuckets.length > nx) {
                     xBuckets.sort((a,b) => b.length - a.length);
                     const selected = xBuckets.slice(0, nx).sort((a,b) => a[0].x - b[0].x);
                     xBuckets.length = 0; xBuckets.push(...selected);
                }
                
                for(let i=0; i<nx; i++) {
                    grid[i] = [];
                    const xItems = xBuckets[i] || xBuckets[xBuckets.length-1]; 
                    
                    const yBuckets = gapSort(xItems, 'y');
                    
                    if(yBuckets.length > ny) {
                         yBuckets.sort((a,b) => b.length - a.length);
                         const selected = yBuckets.slice(0, ny).sort((a,b) => a[0].y - b[0].y);
                         yBuckets.length = 0; yBuckets.push(...selected);
                    }

                    for(let j=0; j<ny; j++) {
                        const yItems = yBuckets[j] || yBuckets[yBuckets.length-1]; 
                        
                        yItems.sort((a,b) => a.z - b.z);

                        grid[i][j] = [];
                        for(let k=0; k<nz; k++) {
                            const item = yItems[k] || yItems[yItems.length-1]; 
                            grid[i][j][k] = item.h;
                        }
                    }
                }
                return grid;
            }

            getStructuredHandles(mesh) {
                if (mesh.userData.gridInfo && this.vertexMap.length > 0) {
                    const segs = mesh.userData.segments;
                    const nx = segs.x + 1, ny = segs.y + 1, nz = segs.z + 1;
                    
                    const grid = Array(nx).fill().map(() => Array(ny).fill().map(() => Array(nz).fill(null)));
                    
                    let dataCount = 0;
                    
                    this.handles.forEach((h, hIdx) => {
                        const vIdx = this.vertexMap.indexOf(hIdx);
                        if(vIdx !== -1 && mesh.userData.gridInfo[vIdx]) {
                            const {x, y, z} = mesh.userData.gridInfo[vIdx];
                            if(x < nx && y < ny && z < nz) {
                                grid[x][y][z] = h;
                                dataCount++;
                            }
                        }
                    });

                    if (dataCount > 0) return grid;
                }
                
                this.cacheGridIndices(mesh);
                return this.getStructuredHandles(mesh);
            }
			
            exitEditMode() {
                this.state.mode = 'object'; this.state.editTool = 'select'; 
                this.resetKnifeTool(); this.orbit.enabled = true;
                this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333));
                this.state.multiSelection = [];
                this.connectionLine.visible = false;
                document.getElementById('action-container').classList.add('hidden');
                
                document.getElementById('tool-select').click();
                this.clearHandles(); 
                if(this.wireframeHelper) { this.state.selectedObj.remove(this.wireframeHelper); this.wireframeHelper = null; }
                
                this.state.userEdges = []; 

                this.gizmo.detach();
				document.getElementById('sub-mode-bar').classList.add('hidden');
                document.getElementById('edit-tools-bar').classList.add('hidden');
                document.getElementById('transform-tools').classList.remove('hidden');
                if(this.state.selectedObj) this.gizmo.attach(this.state.selectedObj);
                document.getElementById('status').innerText = "Modo Objeto";
            }

            clearHandles() { this.handles.forEach(h => { if(h.parent) h.parent.remove(h); }); this.handles = []; this.vertexMap = []; }
            selectObject(mesh) { this.state.selectedObj = mesh; if(mesh) { mesh.material.emissive.setHex(0x333333); if(this.state.mode === 'object') this.gizmo.attach(mesh); } else { this.gizmo.detach(); } }
            
			// ============================================
			// FUNCIÓN TAP BLINDADA (SOLUCIÓN AL BUG)
			// ============================================
			handleTap(x, y) { 
				const rect = this.renderer.domElement.getBoundingClientRect(); 
				const mouse = new THREE.Vector2(((x-rect.left)/rect.width)*2-1, -((y-rect.top)/rect.height)*2+1); 
				this.raycaster.setFromCamera(mouse, this.camera); 
				const statusLabel = document.getElementById('status'); 
			
				// 1. MODO OBJETO (Sin cambios)
				if (this.state.mode === 'object') { 
					const hits = this.raycaster.intersectObjects(this.objects); 
					if (hits.length > 0) { this.selectObject(hits[0].object); statusLabel.innerText = "Objeto Seleccionado"; } 
					else { this.selectObject(null); statusLabel.innerText = "Modo Objeto"; } 
					return; 
				} 
			
				// 2. MODO EDICIÓN
				this.clearSelectionVisuals();
				
				// *** PASO CRÍTICO: Desactivar Gizmo POR DEFECTO ***
				// Esto asegura que si tocas el aire o la cara del cubo sin tocar un componente válido,
				// el gizmo se apaga y NO selecciona el objeto principal.
				this.gizmo.detach();
			
				if (this.state.editTool === 'select') {
					
					// SUB-MODO: VÉRTICES (REEMPLAZAR ESTE BLOQUE)
					if (this.state.selectMode === 'vertex') {
						const targets = [...this.handles];
				
						// 1. PASO DE OCLUSIÓN: ¿Qué tan lejos está la pared visible?
						const meshHits = this.raycaster.intersectObject(this.state.selectedObj);
						let visibleDistanceLimit = Infinity;
						
						// Si golpeamos el objeto, definimos el límite de visión.
						// Le damos +0.15 de margen porque los handles (esferas) sobresalen un poco de la superficie.
						if (meshHits.length > 0) {
							visibleDistanceLimit = meshHits[0].distance + 0.15;
						}
				
						// 2. Intersectamos todos los handles
						const hits = this.raycaster.intersectObjects(targets, true);
						
						// 3. FILTRO MAESTRO: Ignorar handles que están detrás de la pared
						// Solo aceptamos hits cuya distancia sea menor al límite visible
						const visibleHits = hits.filter(h => h.distance < visibleDistanceLimit);
				
						// 4. Validar que sea un handle real
						const validHit = visibleHits.find(h => {
							return this.handles.includes(h.object) || (h.object.parent && this.handles.includes(h.object.parent));
						});
				
						if (validHit) {
							const handle = this.handles.includes(validHit.object) ? validHit.object : validHit.object.parent;
							this.setSelection([handle], "Vértice Seleccionado");
						} 
						// Si no hay hit válido visible, el gizmo se queda apagado (detach).
					} 
					
					// REEMPLAZAR BLOQUE 'edge'
					else if (this.state.selectMode === 'edge') {
						const edgeData = this.findClosestEdge(this.raycaster);
						if (edgeData) {
							// Ahora edgeData tiene .ids (IDs virtuales) y .points (Vector3)
							// Necesitamos encontrar los handles visuales para seleccionarlos
							const h1 = this.virtualMesh.verts[edgeData.ids[0]].handle;
							const h2 = this.virtualMesh.verts[edgeData.ids[1]].handle;
							
							if(h1 && h2) {
								this.setSelection([h1, h2], "Borde Seleccionado");
								this.edgeHighlightHelper.geometry.setFromPoints(edgeData.points);
								this.edgeHighlightHelper.visible = true;
							}
						}
					}
			
					// REEMPLAZAR BLOQUE 'face'
					else if (this.state.selectMode === 'face') {
						// findClosestFace ahora devuelve un array de handles directamente y guarda this.state.selectedFaceId
						const faceHandles = this.findClosestFace(this.raycaster);
						if (faceHandles) {
							this.setSelection(faceHandles, "Cara Seleccionada");
							
							// Dibujar el highlight (cuadrado rojo/naranja)
							// Triangulamos visualmente para el helper (Fan triangulation)
							const pts = [];
							const center = new THREE.Vector3();
							faceHandles.forEach(h => center.add(h.position));
							center.divideScalar(faceHandles.length);
					
							// Crear triángulos visuales para el highlight
							for(let i=0; i<faceHandles.length; i++) {
								pts.push(faceHandles[i].position.x, faceHandles[i].position.y, faceHandles[i].position.z);
								pts.push(faceHandles[(i+1)%faceHandles.length].position.x, faceHandles[(i+1)%faceHandles.length].position.y, faceHandles[(i+1)%faceHandles.length].position.z);
								pts.push(center.x, center.y, center.z);
							}
					
							this.faceHighlightHelper.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
							this.faceHighlightHelper.visible = true;
						}
					}
					return;
				}
			}	
	
					updateGeometryFromHandles() { 
						if (!this.state.selectedObj || !this.virtualMesh) return; 
					
						// 1. Calcular la matriz inversa (Mundo -> Local)
						const inverseMatrix = this.state.selectedObj.matrixWorld.clone().invert();
					
						// 2. SINCRONIZAR: De Handles (Mundo) -> VirtualMesh (Local)
						Object.values(this.virtualMesh.verts).forEach(v => {
							if(v.handle) {
								// Tomamos la posición visual actual (Mundo)
								const worldPos = v.handle.position.clone();
								
								// La convertimos a local relativo al objeto
								const localPos = worldPos.applyMatrix4(inverseMatrix);
					
								// Guardamos el dato local
								v.x = localPos.x;
								v.y = localPos.y;
								v.z = localPos.z;
							}
						});
					
						// 3. REGENERAR GEOMETRÍA (Esto usa los datos locales, así que ya está bien)
						const newGeo = this.virtualMesh.toBufferGeometry();
						
						this.state.selectedObj.geometry.dispose();
						this.state.selectedObj.geometry = newGeo;
						
						if (this.state.mode === 'edit') {
							this.setupDirectWireframe(this.state.selectedObj);
						}
						
						// === NUEVO: GUARDAR EN LA MOCHILA DEL OBJETO ===
						// Esto asegura que si sales y vuelves, la data esté ahí.
						this.state.selectedObj.userData.vmData = this.virtualMesh.toJSON();
					}         
		 
            createHandleMesh(pos) { const hitGeo = new THREE.SphereGeometry(0.15, 8, 8); const hitMat = new THREE.MeshBasicMaterial({ color: 0xff0000, visible: false }); const hitMesh = new THREE.Mesh(hitGeo, hitMat); hitMesh.position.copy(pos); const visualGeo = new THREE.SphereGeometry(0.06, 8, 8); const visualMat = new THREE.MeshBasicMaterial({ color: 0xff3333, depthTest:true, transparent:false }); const visualMesh = new THREE.Mesh(visualGeo, visualMat); hitMesh.add(visualMesh); return hitMesh; }
            
            getFullEdgeLine(edgeData) {
				// La nueva findClosestEdge devuelve { points: [Vector3, Vector3] }
				if (edgeData && edgeData.points) {
					return edgeData.points;
				}
				return [];
			}
            
		findClosestEdge(raycaster) {
			if (!this.virtualMesh || !this.state.selectedObj) return null;
		
			// 1. PASO CRÍTICO: Calcular la barrera visual (Oclusión)
			// Lanzamos el rayo contra la malla sólida para ver qué está al frente.
			const meshHits = raycaster.intersectObject(this.state.selectedObj);
			
			// Si no golpeamos el objeto visualmente, no deberíamos poder seleccionar bordes
			// (A menos que quieras seleccionar bordes en el aire, pero para robustez es mejor esto)
			if (meshHits.length === 0) return null;
		
			// Esta es la distancia máxima permitida. Cualquier cosa detrás de esto está oculta.
			// Le damos un pequeño margen (+0.1 o +0.2) para que los bordes superficiales sean detectables.
			const visibleDistanceLimit = meshHits[0].distance + 0.2;
		
			let bestEdge = null;
			let minDiff = Infinity; // Diferencia entre el rayo y el borde
			
			// Umbral de precisión del mouse (qué tan cerca debo hacer clic)
			const threshold = 0.3; 
			const matrix = this.state.selectedObj.matrixWorld;
			
			// Variables temporales para evitar basura en memoria
			const ptOnRay = new THREE.Vector3();
			const ptOnSeg = new THREE.Vector3();
			const ray = raycaster.ray;
		
			Object.values(this.virtualMesh.faces).forEach(face => {
				const verts = face.verts;
				for (let i = 0; i < verts.length; i++) {
					const id1 = verts[i];
					const id2 = verts[(i + 1) % verts.length];
		
					// Evitar duplicados (procesar 1-2 y 2-1)
					if (id1 > id2) continue; 
					
					const v1 = this.virtualMesh.verts[id1];
					const v2 = this.virtualMesh.verts[id2];
					
					// Transformar a coordenadas MUNDIALES
					const p1World = new THREE.Vector3(v1.x, v1.y, v1.z).applyMatrix4(matrix);
					const p2World = new THREE.Vector3(v2.x, v2.y, v2.z).applyMatrix4(matrix);
		
					// Calcular distancia matemática Rayo <-> Segmento
					const distSq = ray.distanceSqToSegment(p1World, p2World, ptOnRay, ptOnSeg);
		
					if (distSq < threshold) {
						// AQUÍ ESTÁ LA LÓGICA ROBUSTA:
						// Calculamos qué tan lejos está este borde de la cámara
						const distanceToCamera = ray.origin.distanceTo(ptOnSeg);
		
						// Si el borde está más lejos que la pared visible del objeto, LO IGNORAMOS.
						if (distanceToCamera < visibleDistanceLimit) {
							// Es un borde visible, comprobamos si es el más cercano al mouse
							if (distSq < minDiff) {
								minDiff = distSq;
								bestEdge = { 
									ids: [id1, id2], 
									points: [p1World, p2World] 
								};
							}
						}
					}
				}
			});
		
			return bestEdge;
		}	

        findClosestVisibleEdge(raycaster) {
            const mesh = this.state.selectedObj;
            if (!mesh) return null;
            const grid = this.getStructuredHandles(mesh);
            if (!grid) return null;

            const meshHits = raycaster.intersectObject(mesh);
            let maxHitDistance = Infinity;
            if (meshHits.length > 0) {
                maxHitDistance = meshHits[0].distance;
            }

            const segs = mesh.userData.segments;
            let bestEdge = null;
            let minVisualDistSq = Infinity;
            
            const THRESHOLD_SQ = 0.5 * 0.5; 

            const ray = raycaster.ray;
            const ptOnRay = new THREE.Vector3();
            const ptOnSeg = new THREE.Vector3();

            const check = (h1, h2) => {
                if (!h1 || !h2) return;

                const distSq = ray.distanceSqToSegment(h1.position, h2.position, ptOnRay, ptOnSeg);

                if (distSq < THRESHOLD_SQ) {
                    
                    const distanceToCamera = ptOnRay.distanceTo(ray.origin);

                    if (distanceToCamera < maxHitDistance + 0.1) {
                        
                        if (distSq < minVisualDistSq) {
                            minVisualDistSq = distSq;
                            bestEdge = [h1, h2];
                        }
                    }
                }
            };

            if (grid.length > 0) {
                // X Axis
                for(let i=0; i < segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k <= segs.z; k++) 
                    if(grid[i] && grid[i+1] && grid[i][j] && grid[i+1][j]) check(grid[i][j][k], grid[i+1][j][k]);
                // Y Axis
                for(let i=0; i <= segs.x; i++) for(let j=0; j < segs.y; j++) for(let k=0; k <= segs.z; k++) 
                    if(grid[i] && grid[i][j] && grid[i][j+1]) check(grid[i][j][k], grid[i][j+1][k]);
                // Z Axis
                for(let i=0; i <= segs.x; i++) for(let j=0; j <= segs.y; j++) for(let k=0; k < segs.z; k++) 
                    if(grid[i] && grid[i][j] && grid[i][j][k] && grid[i][j][k+1]) check(grid[i][j][k], grid[i][j][k+1]);
            }

            return bestEdge;
        }
	
            drawLoopPreview(axis, index, ratio) { 
                const mesh = this.state.selectedObj; const grid = this.getStructuredHandles(mesh); const segs = mesh.userData.segments; const pts = []; 
                const lerpPos = (h1, h2) => h1.position.clone().lerp(h2.position.clone(), ratio); const addSegment = (pA, pB) => { pts.push(pA, pB); }; 
                if(axis === 'x') { for(let j=0; j<segs.y; j++) addSegment(lerpPos(grid[index][j][0], grid[index+1][j][0]), lerpPos(grid[index][j+1][0], grid[index+1][j+1][0])); for(let k=0; k<segs.z; k++) addSegment(lerpPos(grid[index][segs.y][k], grid[index+1][segs.y][k]), lerpPos(grid[index][segs.y][k+1], grid[index+1][segs.y][k+1])); for(let j=segs.y; j>0; j--) addSegment(lerpPos(grid[index][j][segs.z], grid[index+1][j][segs.z]), lerpPos(grid[index][j-1][segs.z], grid[index+1][j-1][segs.z])); for(let k=segs.z; k>0; k--) addSegment(lerpPos(grid[index][0][k], grid[index+1][0][k]), lerpPos(grid[index][0][k-1], grid[index+1][0][k-1])); } 
                else if(axis === 'y') { for(let i=0; i<segs.x; i++) addSegment(lerpPos(grid[i][index][0], grid[i][index+1][0]), lerpPos(grid[i+1][index][0], grid[i+1][index+1][0])); for(let k=0; k<segs.z; k++) addSegment(lerpPos(grid[segs.x][index][k], grid[segs.x][index+1][k]), lerpPos(grid[segs.x][index][k+1], grid[segs.x][index+1][k+1])); for(let i=segs.x; i>0; i--) addSegment(lerpPos(grid[i][index][segs.z], grid[i][index+1][segs.z]), lerpPos(grid[i-1][index][segs.z], grid[i-1][index+1][segs.z])); for(let k=segs.z; k>0; k--) addSegment(lerpPos(grid[0][index][k], grid[0][index+1][k]), lerpPos(grid[0][index][k-1], grid[0][index+1][k-1])); } 
                else if(axis === 'z') { for(let i=0; i<segs.x; i++) addSegment(lerpPos(grid[i][0][index], grid[i][0][index+1]), lerpPos(grid[i+1][0][index], grid[i+1][0][index+1])); for(let j=0; j<segs.y; j++) addSegment(lerpPos(grid[segs.x][j][index], grid[segs.x][j][index+1]), lerpPos(grid[segs.x][j+1][index], grid[segs.x][j+1][index+1])); for(let i=segs.x; i>0; i--) addSegment(lerpPos(grid[i][segs.y][index], grid[i][segs.y][index+1]), lerpPos(grid[i-1][segs.y][index], grid[i-1][segs.y][index+1])); for(let j=segs.y; j>0; j--) addSegment(lerpPos(grid[0][j][index], grid[0][j][index+1]), lerpPos(grid[0][j-1][index], grid[0][j-1][index+1])); } 
                this.cutPreviewHelper.geometry.setFromPoints(pts); 
            }
            initUI() { 
                const btnObj = document.getElementById('btn-mode-obj'); const btnEdit = document.getElementById('btn-mode-edit'); 
                btnObj.onclick = () => { if(this.state.mode === 'edit') { btnObj.classList.add('active'); btnEdit.classList.remove('active'); this.exitEditMode(); } }; 
                btnEdit.onclick = () => { if(this.state.mode === 'object' && this.state.selectedObj) { btnObj.classList.remove('active'); btnEdit.classList.add('active'); this.enterEditMode(); } }; 
                
				const setSubMode = (mode, id) => {
					document.getElementById(id).onclick = () => {
						this.state.selectMode = mode;
						document.querySelectorAll('.sub-opt').forEach(b => b.classList.remove('active'));
						document.getElementById(id).classList.add('active');
						this.gizmo.detach();
						this.clearSelectionVisuals();
						document.getElementById('status').innerText = `Modo ${mode === 'vertex' ? 'Puntos' : mode === 'edge' ? 'Bordes' : 'Caras'}`;
					}
				};
				setSubMode('vertex', 'sel-vertex');
				setSubMode('edge', 'sel-edge');
				setSubMode('face', 'sel-face');
				this.updateGeometryFromHandles();
				
                document.getElementById('btn-toggle-wire').onclick = () => this.toggleWireframeMode();
                document.getElementById('btn-add').onclick = () => this.addCube(); 
                document.getElementById('btn-delete').onclick = () => { if(this.state.selectedObj && this.state.mode === 'object') { this.scene.remove(this.state.selectedObj); this.objects = this.objects.filter(o => o !== this.state.selectedObj); this.selectObject(null); this.gizmo.detach(); } }; 
                document.getElementById('tool-select').onclick = () => { 
                    this.state.editTool = 'select'; this.updateToolUI('tool-select'); 
                    document.getElementById('status').innerText = "Seleccionar Puntos"; 
                    this.resetKnifeTool(); 
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); 
                    this.state.multiSelection = []; 
                    this.connectionLine.visible = false;
                    document.getElementById('action-container').classList.add('hidden');
                    this.orbit.enabled = true; this.gizmo.attach(this.handles[0]); this.gizmo.detach();
                }; 
                document.getElementById('tool-cut').onclick = () => { 
                    this.state.editTool = 'cut'; this.updateToolUI('tool-cut'); 
                    document.getElementById('status').innerText = "Cuchillo: Selecciona un borde"; 
                    this.gizmo.detach(); this.orbit.enabled = false; 
                    this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333)); this.state.multiSelection = []; 
                    this.connectionLine.visible = false; document.getElementById('action-container').classList.add('hidden');
