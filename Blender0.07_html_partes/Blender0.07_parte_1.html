


<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Jarvis 3D - Selecci√≥n Estricta</title>
    <style>
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: #eee; }
        #viewport { width: 100vw; height: 100vh; display: block; z-index: 0; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 10px; display: flex; flex-direction: column; justify-content: space-between; }
        .header { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; width: 100%; }
        .interactive { pointer-events: auto; }
        .mode-switch { background: #111; border: 1px solid #555; border-radius: 6px; display: flex; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.3); margin-bottom: 10px; }
        .mode-opt { padding: 10px 15px; font-size: 12px; font-weight: bold; color: #777; cursor: pointer; transition: all 0.2s; }
        .mode-opt.active { background: #e67e22; color: white; }
        .footer { display: flex; justify-content: center; pointer-events: none; padding-bottom: 20px; flex-direction: column; align-items: center; gap: 10px;}
        .transform-bar { background: rgba(30,30,30,0.95); border: 1px solid #555; border-radius: 12px; padding: 8px; display: flex; gap: 8px; backdrop-filter: blur(4px); box-shadow: 0 4px 10px rgba(0,0,0,0.4); pointer-events: auto; }
        button { background: #333; color: #ccc; border: 1px solid #444; padding: 12px 16px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        button.active { background: #3498db; color: #fff; border-color: #2980b9; }
        button.btn-green { background: #27ae60; color: white; }
        button.btn-danger { background: #c0392b; color: white; }
        button.btn-action { background: #f1c40f; color: #222; border: 1px solid #f39c12; font-weight: bold; box-shadow: 0 0 15px rgba(241, 196, 15, 0.6); transform: scale(1.1); }
        button.btn-tool { font-size: 18px; padding: 10px 14px; } 
        .btn-icon { padding: 10px 12px; font-size: 16px; }
        #status { position: absolute; top: 15px; left: 50%; transform:translateX(-50%); font-size: 13px; color: #fff; text-shadow: 1px 1px 2px black; pointer-events: none; background: rgba(0,0,0,0.7); padding: 6px 12px; border-radius: 20px; white-space: nowrap; border: 1px solid #444; transition: all 0.2s; }
        .hidden { display: none !important; }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1.1); opacity: 1; } }
        .pop-in { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
		.sub-mode-switch { background: #222; border: 1px solid #444; border-radius: 6px; display: flex; overflow: hidden; margin-top: 5px; }
		.sub-opt { padding: 6px 12px; font-size: 16px; color: #777; cursor: pointer; transition: all 0.2s; border-right: 1px solid #333; }
		.sub-opt:last-child { border-right: none; }
		.sub-opt:hover { background: #333; }
		.sub-opt.active { background: #3498db; color: white; }
		
    </style>
</head>
<body>
    <div id="viewport"></div>
    <div id="ui-layer">
        <div id="status">Listo</div>
        <div class="header">
            <div id="side-panel" class="interactive">
                <div class="mode-switch">
                    <div id="btn-mode-obj" class="mode-opt active">OBJETO</div>
                    <div id="btn-mode-edit" class="mode-opt">EDICI√ìN</div>
                </div>
				<div id="sub-mode-bar" class="sub-mode-switch hidden">
					<div id="sel-vertex" class="sub-opt active" title="V√©rtices">1 Punto</div>
					<div id="sel-edge" class="sub-opt" title="Bordes">2 Borde</div>
					<div id="sel-face" class="sub-opt" title="Caras">3 Cara</div>
				</div>
            </div>
            <div style="display: flex; gap: 8px;" class="interactive">
                <button id="btn-toggle-wire" class="btn-icon" style="background: #444;" title="Alternar Vista">üëÅÔ∏è</button>
                <div style="width:1px; background:#555; margin: 0 2px;"></div>
                <button id="btn-add">Ôºã Cubo</button>
                <button id="btn-export" class="btn-green">‚¨á GLB</button>
            </div>
        </div>
        
        <div id="action-container" class="interactive hidden" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none;">
             <button id="btn-connect-action" class="btn-action pop-in" style="pointer-events: auto;">‚ö° ACCI√ìN</button>
        </div>

        <div class="footer">
            <div class="transform-bar" id="transform-tools">
                <button id="mode-translate" class="active">Mover</button>
                <button id="mode-rotate">Rotar</button>
                <button id="mode-scale">Escalar</button>
                <div style="width:1px; background:#555; margin: 0 5px;"></div>
                <button id="btn-delete" class="btn-danger">üóë</button>
            </div>
            <div class="transform-bar hidden" id="edit-tools-bar">
                <button id="tool-select" class="active btn-tool">üëÜ</button>
                <button id="tool-cut" class="btn-tool" style="background:#d35400; color:white;">üî™</button>
                <button id="tool-connect" class="btn-tool" style="background:#8e44ad; color:white;">üîó</button>
				<button id="tool-extrude" class="btn-tool" style="background:#2ecc71; color:white;">E</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

class VVert {
    constructor(id, x, y, z) {
        this.id = id;
        this.x = x; this.y = y; this.z = z;
        this.handle = null; // Referencia visual (la bolita azul)
    }
}

class VFace {
    constructor(id, vertIds) {
        this.id = id;
        this.verts = vertIds; // Array de IDs [0, 1, 2, 3]
        this.selected = false;
        this.normal = new THREE.Vector3();
    }
}

class VirtualMesh {
    constructor() {
        this.verts = {}; // Diccionario de v√©rtices { id: VVert }
        this.faces = {}; // Diccionario de caras { id: VFace }
        this.vertCounter = 0;
        this.faceCounter = 0;
    }

    addVert(x, y, z) {
        const id = this.vertCounter++;
        this.verts[id] = new VVert(id, x, y, z);
        return id;
    }

    addFace(vertIds) {
        const id = this.faceCounter++;
        this.faces[id] = new VFace(id, vertIds);
        return id;
    }

extrudeFace(faceId, distance) {
        const face = this.faces[faceId];
        if(!face) return;

        // 1. Calcular direcci√≥n de extrusi√≥n (Normal)
        const p0 = this.verts[face.verts[0]];
        const p1 = this.verts[face.verts[1]];
        const p2 = this.verts[face.verts[2]];
        
        const vA = new THREE.Vector3(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z);
        const vB = new THREE.Vector3(p2.x - p0.x, p2.y - p0.y, p2.z - p0.z);
        const normal = new THREE.Vector3().crossVectors(vA, vB).normalize();
        const moveVec = normal.multiplyScalar(distance);

        // 2. Crear los NUEVOS v√©rtices (la "tapa" extruida)
        const oldVertIds = [...face.verts];
        const newVertIds = [];

        oldVertIds.forEach(vid => {
            const oldV = this.verts[vid];
            // Crear copia movida
            const newId = this.addVert(oldV.x + moveVec.x, oldV.y + moveVec.y, oldV.z + moveVec.z);
            newVertIds.push(newId);
        });

        // 3. Crear las caras laterales (Puentes)
        // Conecta: Old1 -> Old2 -> New2 -> New1
        for(let i = 0; i < oldVertIds.length; i++) {
            const nextI = (i + 1) % oldVertIds.length;
            
            const sideFaceVerts = [
                oldVertIds[i],
                oldVertIds[nextI],
                newVertIds[nextI], // Nota el orden para mantener la normal hacia afuera
                newVertIds[i]
            ];
            this.addFace(sideFaceVerts);
        }

        // 4. Mover la cara original a los nuevos v√©rtices (tapa frontal)
        face.verts = newVertIds;

        console.log("Extrusi√≥n completada. Caras totales:", Object.keys(this.faces).length);
    }

    // Convierte esta data abstracta en buffers reales de Three.js
    toBufferGeometry() {
        const positions = [];
        const indices = [];
        const tempVertMap = {}; // Map local ID -> Index Array

        let idxCounter = 0;

        // Aplanar v√©rtices y caras para Three.js
        // Nota: Esto es simplificado. En producci√≥n duplicamos v√©rtices para hard-edges (normales duras).
        
        Object.values(this.faces).forEach(face => {
            // Triangulaci√≥n b√°sica (Fan triangulation para n-gons)
            const vIds = face.verts;
            const rootIdx = idxCounter; // √çndice base local
            
            // A√±adir posiciones de esta cara
            vIds.forEach(vid => {
                const v = this.verts[vid];
                positions.push(v.x, v.y, v.z);
            });

            // Crear tri√°ngulos: 0,1,2 - 0,2,3 - 0,3,4...
            for(let i = 1; i < vIds.length - 1; i++) {
                indices.push(idxCounter, idxCounter + i, idxCounter + i + 1);
            }
            
            idxCounter += vIds.length;
        });

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setIndex(indices);
        geo.computeVertexNormals();
        return geo;
    }
	
	toJSON() {
        return {
            verts: this.verts,       // Guarda la lista de v√©rtices
            faces: this.faces,       // Guarda la lista de caras
            vertCounter: this.vertCounter,
            faceCounter: this.faceCounter
        };
    }

    // === NUEVO: DESERIALIZACI√ìN (CARGAR) ===
    static fromJSON(data) {
        const vm = new VirtualMesh();
        vm.vertCounter = data.vertCounter;
        vm.faceCounter = data.faceCounter;
        
        // Reconstruir V√©rtices (Reactiva la clase VVert)
        Object.keys(data.verts).forEach(key => {
            const v = data.verts[key];
            vm.verts[key] = new VVert(v.id, v.x, v.y, v.z);
        });

        // Reconstruir Caras (Reactiva la clase VFace)
        Object.keys(data.faces).forEach(key => {
            const f = data.faces[key];
            vm.faces[key] = new VFace(f.id, f.verts);
        });
        
        return vm;
    }
	
	
	
}
// --- FIN SISTEMA ---	

        class App {
            constructor() {
                this.state = {
                    mode: 'object', editTool: 'select', 
                    knifeStep: 0, 
                    isCutting: false, isTouching: false,
                    selectedObj: null, pointerData: { x:0, y:0, time:0, isGizmoDragging: false },
                    activeEdge: null, slideRuler: null, cutRatio: 0.0,
                    cutOptions: [],
                    dragStart: { x: 0, y: 0 },
                    multiSelection: [],
                    wireframeMode: 'clean',
                    userEdges: [],
					selectMode: 'vertex', 
					selectedGroup: [],    
					groupStartPos: [],    
					dragGroupOffsets: [], 
                };
                this.objects = []; this.handles = []; this.vertexMap = [];
				this.dummy = new THREE.Object3D(); 
				this.faceHighlightHelper = null;   
                this.wireframeHelper = null; 
                this.edgeHighlightHelper = null; this.cutPreviewHelper = null;
                this.connectionLine = null;

                this.raycaster = new THREE.Raycaster();
                this.raycaster.params.Line.threshold = 0.3; 

                this.initScene();
                this.initControls();
                this.initInteraction();
                this.initUI();
                this.addCube();
                this.renderer.setAnimationLoop(this.render.bind(this));
				this.virtualMesh = null; // A√±adir esto
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x222222);
                this.scene.add(new THREE.GridHelper(30, 30, 0x444444, 0x282828));
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.7)); 
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);

                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(5, 5, 5);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('viewport').appendChild(this.renderer.domElement);

                this.selectionGroup = new THREE.Group();
                this.scene.add(this.selectionGroup);

                const edgeMat = new THREE.LineBasicMaterial({ color: 0xffff00, depthTest: false, linewidth: 5 });
                this.edgeHighlightHelper = new THREE.LineSegments(new THREE.BufferGeometry(), edgeMat);
                this.edgeHighlightHelper.renderOrder = 9999;
                this.scene.add(this.edgeHighlightHelper);

                const cutMat = new THREE.LineBasicMaterial({ color: 0x00ff00, depthTest: false, transparent: false, linewidth: 3 });
                this.cutPreviewHelper = new THREE.LineSegments(new THREE.BufferGeometry(), cutMat);
                this.cutPreviewHelper.renderOrder = 9999;
                this.scene.add(this.cutPreviewHelper);

                const connMat = new THREE.LineBasicMaterial({ color: 0xffdd00, depthTest: false, linewidth: 3 });
                this.connectionLine = new THREE.Line(new THREE.BufferGeometry(), connMat);
                this.connectionLine.renderOrder = 9999;
                this.connectionLine.visible = false;
                this.scene.add(this.connectionLine);
				
				this.scene.add(this.dummy);
				
				const faceGeo = new THREE.BufferGeometry();
				const faceMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.4, side: THREE.DoubleSide, depthTest: false });
				this.faceHighlightHelper = new THREE.Mesh(faceGeo, faceMat);
				this.faceHighlightHelper.renderOrder = 9998;
				this.faceHighlightHelper.visible = false; 
				this.scene.add(this.faceHighlightHelper);
            }

            initControls() {
                this.orbit = new OrbitControls(this.camera, this.renderer.domElement);
                this.orbit.enableDamping = true;
                this.gizmo = new TransformControls(this.camera, this.renderer.domElement);
                this.scene.add(this.gizmo);
                
                this.gizmo.addEventListener('dragging-changed', (e) => {
				this.orbit.enabled = !e.value;
				this.state.pointerData.isGizmoDragging = e.value;
    
				if (e.value && this.state.selectedGroup.length > 1) {
				const center = this.dummy.position.clone();
				this.state.dragGroupOffsets = this.state.selectedGroup.map(h => {
				return new THREE.Vector3().subVectors(h.position, center);
				});
			}
		});

				this.gizmo.addEventListener('change', () => {
					if (this.state.mode === 'edit' && this.state.selectedGroup.length > 1 && this.state.pointerData.isGizmoDragging) {
						const currentDummyPos = this.dummy.position;
						
						this.state.selectedGroup.forEach((h, i) => {
							if (this.state.dragGroupOffsets[i]) {
								const offset = this.state.dragGroupOffsets[i];
								const newPos = currentDummyPos.clone().add(offset);
								h.position.copy(newPos);
							}
						});
						this.updateGeometryFromHandles();
					} 
					else if (this.state.mode === 'edit' && this.state.selectedObj) {
						this.updateGeometryFromHandles();
					}
				});
            }

            initInteraction() {
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('pointerdown', (e) => {
                    this.state.pointerData.x = e.clientX;
                    this.state.pointerData.y = e.clientY;
                    this.state.pointerData.time = Date.now();
                    this.state.isTouching = true;

                    if(this.state.mode === 'edit' && this.state.editTool === 'cut' && this.state.knifeStep === 1) {
                        this.state.isCutting = true;
                        this.state.dragStart = { x: e.clientX, y: e.clientY };
                        this.updateKnifeVisuals(e, 'cut_start');
                    }
                });

                canvas.addEventListener('pointermove', (e) => {
                    if(this.state.mode === 'edit' && this.state.editTool === 'cut' && this.state.isTouching) {
                        if (this.state.knifeStep === 0) {
                            this.updateKnifeVisuals(e, 'search');
                        }
                        else if (this.state.isCutting) {
                            this.updateKnifeVisuals(e, 'cut_move');
                        }
                    }
                });

                canvas.addEventListener('pointerup', (e) => {
                    this.state.isTouching = false;
                    if(this.state.pointerData.isGizmoDragging) return;
                    const dist = Math.hypot(e.clientX - this.state.pointerData.x, e.clientY - this.state.pointerData.y);

                    if (this.state.mode === 'edit' && this.state.editTool === 'cut') { 
                        if (this.state.knifeStep === 0) {
                            if (this.state.activeEdge) { 
                                this.updateKnifeVisuals(e, 'select');
                            }
                        }
                        else if (this.state.isCutting) {
                            this.updateKnifeVisuals(e, 'apply');
                            this.state.isCutting = false;
                        }
                        return; 
                    }
                    
                    if(dist < 10 && (Date.now() - this.state.pointerData.time) < 300) this.handleTap(e.clientX, e.clientY);
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            getPairId(id1, id2) {
                return (id1 < id2) ? `${id1}_${id2}` : `${id2}_${id1}`;
            }

            syncUserEdgesToMesh() {
                if(this.state.selectedObj) {
                    this.state.selectedObj.userData.userEdges = [...this.state.userEdges];
                }
            }

            addUserEdge(id1, id2) {
                const pair = this.getPairId(id1, id2);
                if (!this.state.userEdges.includes(pair)) {
                    this.state.userEdges.push(pair);
                    this.syncUserEdgesToMesh(); 
                }
            }

            removeUserEdge(id1, id2) {
                const pair = this.getPairId(id1, id2);
                const idx = this.state.userEdges.indexOf(pair);
                if (idx !== -1) {
                    this.state.userEdges.splice(idx, 1);
                    this.syncUserEdgesToMesh();
                }
            }

            hasUserEdge(id1, id2) {
                const pair = this.getPairId(id1, id2);
                return this.state.userEdges.includes(pair);
            }

            toggleConnectSelection(handle) {
                const idx = this.state.multiSelection.indexOf(handle);
                if (idx > -1) {
                    handle.children[0].material.color.setHex(0xff3333); 
                    this.state.multiSelection.splice(idx, 1);
                } else {
                    if (this.state.multiSelection.length >= 2) {
                        const old = this.state.multiSelection.shift();
                        old.children[0].material.color.setHex(0xff3333);
                    }
                    handle.children[0].material.color.setHex(0x2ecc71);
                    this.state.multiSelection.push(handle);
                }

                if (this.state.multiSelection.length === 2) {
                    const h1 = this.state.multiSelection[0];
                    const h2 = this.state.multiSelection[1];
                    const id1 = this.handles.indexOf(h1);
                    const id2 = this.handles.indexOf(h2);

                    const exists = this.hasUserEdge(id1, id2);
                    const btn = document.getElementById('btn-connect-action');
                    
                    if (exists) {
                        btn.innerText = "‚ö° DISOLVER";
                        btn.style.background = "#e74c3c"; 
                    } else {
                        btn.innerText = "‚ö° CONECTAR";
                        btn.style.background = "#f1c40f"; 
                    }

                    const pts = [h1.position, h2.position];
                    this.connectionLine.geometry.setFromPoints(pts);
                    this.connectionLine.visible = true;
                    document.getElementById('action-container').classList.remove('hidden');
                } else {
                    this.connectionLine.visible = false;
                    document.getElementById('action-container').classList.add('hidden');
                }
            }

            performConnection() {
                if (this.state.multiSelection.length !== 2) return;
                const mesh = this.state.selectedObj; if (!mesh) return;

                const h1 = this.state.multiSelection[0];
                const h2 = this.state.multiSelection[1];
                const id1 = this.handles.indexOf(h1);
