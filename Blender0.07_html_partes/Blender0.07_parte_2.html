


                const id2 = this.handles.indexOf(h2);

                if (this.hasUserEdge(id1, id2)) {
                    this.removeUserEdge(id1, id2); 
                    document.getElementById('status').innerText = "Línea Disuelta (Visual)";
                } else {
                    this.addUserEdge(id1, id2); 
                    
                    const vIndices1 = []; const vIndices2 = [];
                    this.vertexMap.forEach((handleIdx, vIdx) => {
                        if (handleIdx === id1) vIndices1.push(vIdx);
                        if (handleIdx === id2) vIndices2.push(vIdx);
                    });

                    if (vIndices1.length > 0 && vIndices2.length > 0) {
                        const indexAttr = mesh.geometry.index;
                        const indices = indexAttr.array;
                        const isG1 = (i) => vIndices1.includes(i);
                        const isG2 = (i) => vIndices2.includes(i);
                        
                        let success = false;
                        const trisP1 = [];
                        for(let i=0; i<indices.length; i+=3) {
                            if(isG1(indices[i]) || isG1(indices[i+1]) || isG1(indices[i+2])) trisP1.push(i);
                        }

                        const replaceInTri = (baseIdx, oldVal, newVal) => {
                            if(indices[baseIdx] == oldVal) indices[baseIdx] = newVal;
                            else if(indices[baseIdx+1] == oldVal) indices[baseIdx+1] = newVal;
                            else if(indices[baseIdx+2] == oldVal) indices[baseIdx+2] = newVal;
                        };

                        for (let t1 of trisP1) {
                            if(success) break;
                            const vA = [indices[t1], indices[t1+1], indices[t1+2]];
                            for(let t2=0; t2<indices.length; t2+=3) {
                                if(t1 === t2) continue;
                                const vB = [indices[t2], indices[t2+1], indices[t2+2]];
                                const shared = vA.filter(v => vB.includes(v));
                                if(shared.length === 2) {
                                    const uniqueA = vA.find(v => !shared.includes(v));
                                    const uniqueB = vB.find(v => !shared.includes(v));
                                    const p1InShared = shared.some(v => isG1(v));
                                    const p2InShared = shared.some(v => isG2(v));
                                    
                                    if(p1InShared && p2InShared) {
                                        success = true; break; 
                                    }

                                    const isConnectCase = (isG1(uniqueA) && isG2(uniqueB)) || (isG1(uniqueB) && isG2(uniqueA));
                                    if(isConnectCase) {
                                        const s0 = shared[0]; const s1 = shared[1];
                                        replaceInTri(t1, s1, uniqueB); replaceInTri(t2, s0, uniqueA);
                                        success = true; document.getElementById('status').innerText = "Conexión Creada"; break;
                                    }
                                }
                            }
                        }
                        if(success) { mesh.geometry.index.needsUpdate = true; mesh.geometry.computeVertexNormals(); }
                    }
                }

                this.setupDirectWireframe(mesh);

                this.state.multiSelection.forEach(h => h.children[0].material.color.setHex(0xff3333));
                this.state.multiSelection = [];
                this.connectionLine.visible = false;
                document.getElementById('action-container').classList.add('hidden');
            }

            updateWireframeRealtime() {
                const mesh = this.state.selectedObj; if(!mesh) return;
                
                if(this.wireframeHelper) { 
                    mesh.remove(this.wireframeHelper); 
                    if(this.wireframeHelper.geometry) this.wireframeHelper.geometry.dispose();
                    this.wireframeHelper = null;
                }
                
                let geometry;
                if (this.state.wireframeMode === 'full') {
                    geometry = new THREE.WireframeGeometry(mesh.geometry);
                } else {
                    const grid = this.getStructuredHandles(mesh);
                    if (!grid) return;
                    
                    const segs = mesh.userData.segments;
                    const nx = grid.length; 
                    const ny = grid[0].length; 
                    const nz = grid[0][0].length;
                    const newPoints = [];

                    const getPos = (i,j,k) => {
                        const p = grid[i][j][k].position.clone();
                        mesh.worldToLocal(p);
                        return p;
                    };

                    for(let i=0; i<nx; i++) {
                        for(let j=0; j<ny; j++) {
                            for(let k=0; k<nz; k++) {
                                const p = getPos(i,j,k);
                                if (i < nx - 1) { const px = getPos(i+1, j, k); newPoints.push(p.x, p.y, p.z, px.x, px.y, px.z); }
                                if (j < ny - 1) { const py = getPos(i, j+1, k); newPoints.push(p.x, p.y, p.z, py.x, py.y, py.z); }
                                if (k < nz - 1) { const pz = getPos(i, j, k+1); newPoints.push(p.x, p.y, p.z, pz.x, pz.y, pz.z); }
                            }
                        }
                    }

                    this.state.userEdges.forEach(pairStr => {
                        const parts = pairStr.split('_');
                        const h1 = this.handles[parseInt(parts[0])];
                        const h2 = this.handles[parseInt(parts[1])];
                        if (h1 && h2) {
                            const p1 = h1.position.clone(); mesh.worldToLocal(p1);
                            const p2 = h2.position.clone(); mesh.worldToLocal(p2);
                            newPoints.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
                        }
                    });

                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(newPoints, 3));
                }

                const mat = new THREE.LineBasicMaterial({ color: 0xffaa00, depthTest: false, opacity: 1, transparent: false });
                this.wireframeHelper = new THREE.LineSegments(geometry, mat);
                this.wireframeHelper.renderOrder = 999;
                mesh.add(this.wireframeHelper);
            }
			
			toggleWireframeMode() {
				// Alternar entre modos
				if (this.state.wireframeMode === 'clean') {
				this.state.wireframeMode = 'full';
				document.getElementById('status').innerText = "Vista: Alambre Completo";
    } else {
        this.state.wireframeMode = 'clean';
        document.getElementById('status').innerText = "Vista: Limpia";
    }
    
    // Forzar actualización visual
    if (this.state.selectedObj) {
        this.updateWireframeRealtime();
    }
}

            updateKnifeVisuals(mouseEvent, phase) {
                if(!this.state.selectedObj) return;
                const rect = this.renderer.domElement.getBoundingClientRect();
                
                const getScreenPos = (vec3) => {
                    const v = vec3.clone().project(this.camera);
                    return new THREE.Vector2(
                        (v.x * .5 + .5) * rect.width + rect.left,
                        -(v.y * .5 - .5) * rect.height + rect.top
                    );
                };

                const mouseNDS = new THREE.Vector2(
                    ((mouseEvent.clientX - rect.left)/rect.width)*2-1, 
                    -((mouseEvent.clientY - rect.top)/rect.height)*2+1
                );
                const mousePx = new THREE.Vector2(mouseEvent.clientX, mouseEvent.clientY);

                if (phase === 'search') {
                    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(mouseNDS, this.camera);
                    const edge = this.findClosestEdge(raycaster);
                    
                    if(edge) {
                        this.state.activeEdge = edge;
                        const fullLinePoints = this.getFullEdgeLine(edge);
                        this.edgeHighlightHelper.geometry.setFromPoints(fullLinePoints);
                        this.edgeHighlightHelper.material.color.setHex(0xffff00); 
                        this.edgeHighlightHelper.visible = true;
                        this.cutPreviewHelper.visible = false;
                        document.getElementById('status').innerText = "Loop Detectado";
                    } else {
                        this.edgeHighlightHelper.visible = false;
                        this.cutPreviewHelper.visible = false;
                        this.state.activeEdge = null;
                        document.getElementById('status').innerText = "Cuchillo: Selecciona un borde";
                    }
                }
                
                else if (phase === 'select') {
                    if (this.state.activeEdge) {
                        this.state.knifeStep = 1;
                        this.edgeHighlightHelper.material.color.setHex(0x00ff00); 
                        
                        this.cutPreviewHelper.visible = false; 
                        
                        document.getElementById('status').innerText = "Arrastra para ajustar";

                        const edge = this.state.activeEdge;
                        const grid = this.getStructuredHandles(this.state.selectedObj);
                        const { axis, x, y, z } = edge;
                        const segs = this.state.selectedObj.userData.segments;
                        const options = [];

                        if (axis === 'y') {
                            options.push({ start: grid[0][y][z].position, end: grid[segs.x][y][z].position, axis: 'x', range: segs.x });
                            options.push({ start: grid[x][y][0].position, end: grid[x][y][segs.z].position, axis: 'z', range: segs.z });
                        }
                        else if (axis === 'x' || axis === 'z') {
                            options.push({ start: grid[x][0][z].position, end: grid[x][segs.y][z].position, axis: 'y', range: segs.y });
                        }
                        this.state.cutOptions = options;
                    }
                }

                else if (phase === 'cut_start' || phase === 'cut_move') {
                    if (phase === 'cut_start') this.state.knifeStep = 2;

                    let bestOption = null, bestDist = Infinity;
                    const options = this.state.cutOptions;

                    if (!options || options.length === 0) return;

                    options.forEach(opt => {
                        const p1 = getScreenPos(opt.start);
                        const p2 = getScreenPos(opt.end);
                        const l2 = p1.distanceToSquared(p2);
                        if (l2 < 1) return;
                        
                        let t = ((mousePx.x - p1.x) * (p2.x - p1.x) + (mousePx.y - p1.y) * (p2.y - p1.y)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        const proj = new THREE.Vector2().copy(p1).lerp(p2, t);
                        const d = mousePx.distanceTo(proj);
                        
                        if (d < bestDist) { bestDist = d; bestOption = opt; }
                    });

                    if (!bestOption) bestOption = (this.state.dragInfo && this.state.dragInfo.ruler) || options[0];

                    if (!this.state.dragInfo || this.state.dragInfo.ruler !== bestOption) {
                        
                        const p1 = getScreenPos(bestOption.start);
                        const p2 = getScreenPos(bestOption.end);
                        const lineVec = new THREE.Vector2().subVectors(p2, p1);
                        const screenLength = lineVec.length();
                        
                        let currentAbsT = mousePx.clone().sub(p1).dot(lineVec) / (screenLength * screenLength);
                        currentAbsT = Math.max(0, Math.min(1, currentAbsT));

                        this.state.dragInfo = {
                            startMouse: mousePx.clone(),
                            startT: currentAbsT,
                            lineVecNorm: lineVec.normalize(),
                            virtualLength: 400,             
                            ruler: bestOption
                        };
                        
                        this.cutPreviewHelper.visible = true;
                    }

                    const drag = this.state.dragInfo;
                    const delta = new THREE.Vector2().subVectors(mousePx, drag.startMouse);
                    const moveProj = delta.dot(drag.lineVecNorm);
                    
                    let newT = drag.startT + (moveProj / drag.virtualLength);
                    newT = Math.max(0.01, Math.min(0.99, newT));
                    
                    this.updateCutVisualsInternal(newT, drag.ruler);
                    this.state.slideRuler = drag.ruler;
                }

                else if (phase === 'apply') {
                    if (this.cutPreviewHelper.visible && this.state.slideRuler) {
                        const ruler = this.state.slideRuler;
                        const totalSegs = ruler.range;
                        const globalVal = this.state.cutRatio * totalSegs;
                        const index = Math.min(Math.floor(globalVal), totalSegs - 1);
                        const localRatio = Math.max(0.01, Math.min(0.99, globalVal - index));
                        this.applyCut(ruler.axis, index, localRatio);
                    }
                    this.resetKnifeTool();
                    this.state.dragInfo = null;
                }
            }

            updateCutVisualsInternal(t, ruler) {
                this.state.cutRatio = t;
                const totalSegs = ruler.range;
                const globalVal = t * totalSegs;
                const index = Math.floor(globalVal);
                const localRatio = globalVal - index;
                const safeIndex = Math.min(index, totalSegs - 1);
                const safeRatio = (index >= totalSegs) ? 0.99 : localRatio;
                this.drawLoopPreview(ruler.axis, safeIndex, safeRatio);
            }

            setupDirectWireframe(mesh) {
				// 1. Limpieza previa
				if(this.wireframeHelper) { 
					mesh.remove(this.wireframeHelper); 
					if(this.wireframeHelper.geometry) this.wireframeHelper.geometry.dispose(); 
					this.wireframeHelper = null; 
				}
			
				// Solo funciona si tenemos datos lógicos
				if (!this.virtualMesh) return;
			
				const positions = [];
				const processedEdges = new Set(); // Para no dibujar la misma línea dos veces
			
				// 2. Recorrer cada cara virtual para extraer bordes
				Object.values(this.virtualMesh.faces).forEach(face => {
					const verts = face.verts;
					for (let i = 0; i < verts.length; i++) {
						const id1 = verts[i];
						const id2 = verts[(i + 1) % verts.length]; // Conectar con el siguiente
						
						// Crear una clave única para el borde (ej: "5_12") ordenando menor_mayor
						const key = (id1 < id2) ? `${id1}_${id2}` : `${id2}_${id1}`;
						
						if (!processedEdges.has(key)) {
							processedEdges.add(key); // Marcar como dibujado
							
							// Obtener posiciones LOCALES (porque el helper será hijo del mesh)
							const v1 = this.virtualMesh.verts[id1];
							const v2 = this.virtualMesh.verts[id2];
							
							positions.push(v1.x, v1.y, v1.z);
							positions.push(v2.x, v2.y, v2.z);
						}
					}
				});
			
				// 3. Crear Geometría de Líneas
				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
			
				// 4. Material "No-XRay"
				// depthTest: true hace que las líneas se oculten detrás del objeto sólido
				const material = new THREE.LineBasicMaterial({ 
					color: 0xff5500, // Naranja Blender
					depthTest: true, 
					opacity: 1
				});
				
				this.wireframeHelper = new THREE.LineSegments(geometry, material);
				
				// IMPORTANTE: Para evitar el "Z-Fighting" (parpadeo de líneas), 
				// asegúrate de que tu material del objeto tenga polygonOffset.
				// Si usas el material azul por defecto del código anterior, ya lo tiene.
				
				mesh.add(this.wireframeHelper);
			}

            resetKnifeTool() {
                this.state.knifeStep = 0; this.state.activeEdge = null; this.state.isCutting = false;
                this.edgeHighlightHelper.visible = false; this.cutPreviewHelper.visible = false;
                this.edgeHighlightHelper.material.color.setHex(0xffff00); document.getElementById('status').innerText = "Cuchillo: Selecciona un borde";
            }

            applyCut(axis, index, ratio) {
                const mesh = this.state.selectedObj; 
                if(!mesh) return;

                const grid = this.getStructuredHandles(mesh);
                if (!grid) {
                    console.error("Error: No se pudo leer la estructura del objeto.");
                    return;
                }

                const segs = mesh.userData.segments;
                const old_nx = segs.x + 1, old_ny = segs.y + 1, old_nz = segs.z + 1;
                const newPositions = [];
                const lerpHandles = (h1, h2, t) => h1.position.clone().lerp(h2.position.clone(), t);

                try {
                    if(axis === 'x') { 
                        for(let i=0; i < old_nx; i++) { 
                            for(let j=0; j<old_ny; j++) for(let k=0; k<old_nz; k++) {
                                if(grid[i][j][k]) newPositions.push(grid[i][j][k].position.clone());
                                else newPositions.push(new THREE.Vector3()); 
                            }
                            if(i === index) {
                                for(let j=0; j<old_ny; j++) for(let k=0; k<old_nz; k++) {
                                    if(grid[i][j][k] && grid[i+1][j][k]) newPositions.push(lerpHandles(grid[i][j][k], grid[i+1][j][k], ratio));
                                    else newPositions.push(new THREE.Vector3());
                                }
                            }
                        } segs.x++; 
                    } 
                    else if(axis === 'y') { 
                        for(let i=0; i<old_nx; i++) { 
                            for(let j=0; j<old_ny; j++) { 
                                for(let k=0; k<old_nz; k++) {
                                    if(grid[i][j][k]) newPositions.push(grid[i][j][k].position.clone());
                                    else newPositions.push(new THREE.Vector3());
                                }
                                if(j === index) {
                                    for(let k=0; k<old_nz; k++) {
                                        if(grid[i][j][k] && grid[i][j+1][k]) newPositions.push(lerpHandles(grid[i][j][k], grid[i][j+1][k], ratio));
                                        else newPositions.push(new THREE.Vector3());
                                    }
                                }
                            } 
                        } segs.y++; 
                    }
                    else if(axis === 'z') { 
                        for(let i=0; i<old_nx; i++) { 
                            for(let j=0; j<old_ny; j++) { 
                                for(let k=0; k<old_nz; k++) { 
                                    if(grid[i][j][k]) newPositions.push(grid[i][j][k].position.clone());
                                    else newPositions.push(new THREE.Vector3());
                                    
                                    if(k === index) {
                                        if(grid[i][j][k] && grid[i][j][k+1]) newPositions.push(lerpHandles(grid[i][j][k], grid[i][j][k+1], ratio));
                                        else newPositions.push(new THREE.Vector3());
                                    }
                                } 
                            } 
                        } segs.z++; 
                    }
                } catch (e) {
                    console.error("Error calculando corte:", e);
                    return; 
                }

                const newGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5, segs.x, segs.y, segs.z);
                mesh.geometry.dispose(); 
                mesh.geometry = newGeo;
                
                mesh.userData.gridInfo = null;
                
                this.enterEditMode(true); 

                const currentStructured = this.getStructuredHandles(mesh);
                const targetOrder = [];
                const n_nx = segs.x + 1, n_ny = segs.y + 1, n_nz = segs.z + 1;

                if(axis === 'x') for(let i=0; i<n_nx; i++) for(let j=0; j<n_ny; j++) for(let k=0; k<n_nz; k++) targetOrder.push(currentStructured[i][j][k]);
                else if(axis === 'y') for(let i=0; i<n_nx; i++) for(let j=0; j<n_ny; j++) for(let k=0; k<n_nz; k++) targetOrder.push(currentStructured[i][j][k]);
                else for(let i=0; i<n_nx; i++) for(let j=0; j<n_ny; j++) for(let k=0; k<n_nz; k++) targetOrder.push(currentStructured[i][j][k]);

                for(let i=0; i<targetOrder.length; i++) {
                    if(targetOrder[i] && newPositions[i]) {
                        targetOrder[i].position.copy(newPositions[i]);
                    }
                }
                this.updateGeometryFromHandles();
            }

            enterEditMode(resetPositions = true) {
				const mesh = this.state.selectedObj; 
				if (!mesh) return;
			
				this.state.mode = 'edit';
				this.gizmo.detach();
				this.clearHandles(); 
			
				// Forzar actualización de matrices para evitar errores de posición
				mesh.updateMatrixWorld(true);
			
				// LÓGICA DE CARGA INTELIGENTE
				// 1. ¿Tiene datos guardados? -> Cárgalos
				if (mesh.userData.vmData) {
					console.log("Restaurando malla modificada...");
					this.virtualMesh = VirtualMesh.fromJSON(mesh.userData.vmData);
				} 
				// 2. ¿No tiene datos? -> Crea la inicial (Bounding Box)
				else if (!this.virtualMesh || resetPositions) {
					console.log("Creando malla inicial...");
					this.virtualMesh = new VirtualMesh();
					
					// ... (Aquí va tu código de BoundingBox que hicimos en el paso anterior) ...
					const geo = mesh.geometry;
					geo.computeBoundingBox();
					const box = geo.boundingBox;
					const rx = (box.max.x - box.min.x) / 2;
					const ry = (box.max.y - box.min.y) / 2;
					const rz = (box.max.z - box.min.z) / 2;
					
					// ... (Tus addVert y addFace iniciales) ...
					const v0 = this.virtualMesh.addVert(-rx, -ry,  rz);
					const v1 = this.virtualMesh.addVert( rx, -ry,  rz);
					const v2 = this.virtualMesh.addVert(-rx,  ry,  rz);
					const v3 = this.virtualMesh.addVert( rx,  ry,  rz);
					const v4 = this.virtualMesh.addVert(-rx, -ry, -rz);
					const v5 = this.virtualMesh.addVert( rx, -ry, -rz);
					const v6 = this.virtualMesh.addVert(-rx,  ry, -rz);
					const v7 = this.virtualMesh.addVert( rx,  ry, -rz);
			
					this.virtualMesh.addFace([v0, v1, v3, v2]);
					this.virtualMesh.addFace([v5, v4, v6, v7]);
					this.virtualMesh.addFace([v4, v0, v2, v6]);
					this.virtualMesh.addFace([v1, v5, v7, v3]);
					this.virtualMesh.addFace([v2, v3, v7, v6]);
					this.virtualMesh.addFace([v4, v5, v1, v0]);
				}
			
				// 3. Crear Handles (Esto sigue igual, usando requestAnimationFrame por seguridad)
				requestAnimationFrame(() => {
					Object.values(this.virtualMesh.verts).forEach(v => {
						const localPos = new THREE.Vector3(v.x, v.y, v.z);
						const worldPos = localPos.applyMatrix4(mesh.matrixWorld);
						const worldPos = localPos.applyMatrix4(mesh.matrixWorld);
			
						const handle = this.createHandleMesh(worldPos);
